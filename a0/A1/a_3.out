--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./classify_v1 rfile dfile 1009072 4 1
Data file:        cachegrind.out.32473
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr           Dr                     D1mr             DLmr            Dw                  D1mw             DLmw             
--------------------------------------------------------------------------------
5,793,649,634 (100.0%) 2,697 (100.0%) 2,328 (100.0%) 1,253,244,174 (100.0%) 914,707 (100.0%) 10,721 (100.0%) 74,602,534 (100.0%) 702,190 (100.0%) 322,217 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                     D1mr             DLmr           Dw                  D1mw             DLmw              file:function
--------------------------------------------------------------------------------
5,029,332,814 (86.81%)   0            0          1,006,875,638 (80.34%)     616 ( 0.07%)     0                   0                0                0           /home/cse/dual/cs5190421/COL380/a1/A1/classify_v1.h:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]
  234,188,449 ( 4.04%)  18 ( 0.67%)  14 ( 0.60%)    55,455,676 ( 4.42%)       8 ( 0.00%)     0          27,066,072 (36.28%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
  124,914,753 ( 2.16%)   6 ( 0.22%)   5 ( 0.21%)    40,289,597 ( 3.21%)       0              0           6,844,633 ( 9.17%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   97,070,475 ( 1.68%)   7 ( 0.26%)   6 ( 0.26%)    52,969,461 ( 4.23%)     336 ( 0.04%)   120 ( 1.12%)  6,845,468 ( 9.18%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   56,001,000 ( 0.97%)   1 ( 0.04%)   1 ( 0.04%)    15,711,408 ( 1.25%)       0              0           1,011,072 ( 1.36%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   39,432,111 ( 0.68%)   5 ( 0.19%)   5 ( 0.21%)    15,166,099 ( 1.21%)       5 ( 0.00%)     1 ( 0.01%)  6,066,442 ( 8.13%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::sentry::sentry(std::istream&, bool)
   34,376,486 ( 0.59%)   3 ( 0.11%)   3 ( 0.13%)    10,110,730 ( 0.81%)       0              0           6,066,440 ( 8.13%) 126,135 (17.96%)       0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::operator>>(int&)
   21,232,533 ( 0.37%)   3 ( 0.11%)   1 ( 0.04%)     9,099,657 ( 0.73%)       8 ( 0.00%)     0           5,055,365 ( 6.78%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::__use_cache<std::__numpunct_cache<char> >::operator()(std::locale const&) const
   17,759,788 ( 0.31%)   4 ( 0.15%)   4 ( 0.17%)     7,063,536 ( 0.56%) 126,210 (13.80%)     0           1,009,092 ( 1.35%) 126,142 (17.96%)       0           /home/cse/dual/cs5190421/COL380/a1/A1/classify_v1.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.2]
   16,145,270 ( 0.28%)  12 ( 0.44%)  12 ( 0.52%)     3,027,243 ( 0.24%)      10 ( 0.00%)     0           2,018,191 ( 2.71%) 126,136 (17.96%) 126,134 (39.15%)  ???:readData(char const*, unsigned int)
   15,549,617 ( 0.27%)  15 ( 0.56%)  15 ( 0.64%)     3,009,031 ( 0.24%)      10 ( 0.00%)     0           2,010,050 ( 2.69%)  61,876 ( 8.81%)  61,876 (19.20%)  ???:readRanges(char const*)
   12,132,864 ( 0.21%)   1 ( 0.04%)   1 ( 0.04%)     4,044,288 ( 0.32%)       2 ( 0.00%)     0           3,033,216 ( 4.07%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istream::operator>>(int&)
   11,122,168 ( 0.19%)   3 ( 0.11%)   2 ( 0.09%)     4,044,542 ( 0.32%)       3 ( 0.00%)     0           1,011,197 ( 1.36%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:std::istream::sentry::sentry(std::istream&, bool)
    9,877,850 ( 0.17%)   1 ( 0.04%)   1 ( 0.04%)             1 ( 0.00%)       0              0           1,011,072 ( 1.36%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/char_traits.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
    8,072,630 ( 0.14%)   5 ( 0.19%)   4 ( 0.17%)     2,018,157 ( 0.16%) 126,136 (13.79%)     0                  12 ( 0.00%)       1 ( 0.00%)       0           ???:timedwork(Data&, Ranges const&, unsigned int)
    7,077,504 ( 0.12%)   3 ( 0.11%)   1 ( 0.04%)     3,033,216 ( 0.24%)       0              0           1,011,072 ( 1.36%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/basic_string.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
    7,063,516 ( 0.12%)   0            0              2,018,144 ( 0.16%)   1,004 ( 0.11%)     0           1,009,072 ( 1.35%)       0                0           /home/cse/dual/cs5190421/COL380/a1/A1/classify_v1.h:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]
    6,054,576 ( 0.10%)   2 ( 0.07%)   2 ( 0.09%)     2,018,184 ( 0.16%) 127,159 (13.90%)     0                  20 ( 0.00%)       3 ( 0.00%)       0           /home/cse/dual/cs5190421/COL380/a1/A1/classify_v1.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]
    6,054,520 ( 0.10%)   3 ( 0.11%)   3 ( 0.13%)     1,009,112 ( 0.08%) 504,553 (55.16%)     0           1,009,092 ( 1.35%)      13 ( 0.00%)       2 ( 0.00%)  /home/cse/dual/cs5190421/COL380/a1/A1/classify_v1.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/A1/classify_v1.h
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr           DLmr       Dw                 D1mw             DLmw             

-- line 13 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .           Data classify(Data &D, const Ranges &R, unsigned int numt);
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .           class alignas(32) Counter
            .          .          .                      .              .          .                  .                .                .           { // Aligned allocation per counter. Is that enough?
            .          .          .                      .              .          .                  .                .                .             // Keeps per-thread subcount.
            .          .          .                      .              .          .                  .                .                .           public:
            .          .          .                      .              .          .                  .                .                .               Counter(unsigned int num = MAXTHREADS)
            .          .          .                      .              .          .                  .                .                .               {
        1,001 ( 0.00%) 0          0                      0              0          0              1,001 ( 0.00%)       1 ( 0.00%)       1 ( 0.00%)          _numcount = num;
        3,003 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0              2,002 ( 0.00%)       0                0                   _counts = new unsigned int[num];
            .          .          .                      .              .          .                  .                .                .                   assert(_counts != NULL);
            .          .          .                      .              .          .                  .                .                .                   zero();
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               void zero()
            .          .          .                      .              .          .                  .                .                .               { // Initialize
      135,135 ( 0.00%) 0          0                  1,001 ( 0.00%)     0          0                  0                0                0                   for (int i = 0; i < _numcount; i++)
      128,128 ( 0.00%) 0          0                      0              0          0             64,064 ( 0.09%)   3,176 ( 0.45%)   3,151 ( 0.98%)              _counts[i] = 0;
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               void increase(unsigned int id)
            .          .          .                      .              .          .                  .                .                .               { // If each sub-counter belongs to a thread mutual exclusion is not needed
    2,018,144 ( 0.03%) 0          0              1,009,072 ( 0.08%)     0          0                  0                0                0                   assert(id < _numcount);
    5,045,372 ( 0.09%) 0          0              1,009,072 ( 0.08%) 1,004 ( 0.11%) 0          1,009,072 ( 1.35%)       0                0                   _counts[id]++;
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               void xincrease(unsigned int id)
            .          .          .                      .              .          .                  .                .                .               { // Safe increment
            .          .          .                      .              .          .                  .                .                .                   assert(id < _numcount);
            .          .          .                      .              .          .                  .                .                .                   const std::lock_guard<std::mutex> lock(cmutex);
            .          .          .                      .              .          .                  .                .                .                   _counts[id]++;
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               unsigned int get(unsigned int id) const
            .          .          .                      .              .          .                  .                .                .               { // return subcounter value for specific thread
        8,008 ( 0.00%) 0          0                      0              0          0                  0                0                0                   assert(id < _numcount);
        8,008 ( 0.00%) 0          0                  4,004 ( 0.00%) 1,001 ( 0.11%) 0                  0                0                0                   return _counts[id];
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               void inspect()
            .          .          .                      .              .          .                  .                .                .               {
            .          .          .                      .              .          .                  .                .                .                   std::cout << "Subcounts -- ";
            .          .          .                      .              .          .                  .                .                .                   for (int i = 0; i < _numcount; i++)
            .          .          .                      .              .          .                  .                .                .                       std::cout << i << ":" << _counts[i] << " ";
            .          .          .                      .              .          .                  .                .                .                   std::cout << "\n";
-- line 57 ----------------------------------------
-- line 69 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .               Range(int a = 1, int b = 0)
            .          .          .                      .              .          .                  .                .                .               { // Constructor. Defaults to *bad* range
            .          .          .                      .              .          .                  .                .                .                   lo = a;
            .          .          .                      .              .          .                  .                .                .                   hi = b;
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               bool within(int val) const
            .          .          .                      .              .          .                  .                .                .               { // Return if val is within this range
2,514,666,405 (43.40%) 0          0          1,005,866,562 (80.26%)   615 ( 0.07%) 0                  0                0                0                   return (lo <= val && val <= hi);
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               bool strictlyin(int val) const
            .          .          .                      .              .          .                  .                .                .               { // Return if val is strictly inside this range
            .          .          .                      .              .          .                  .                .                .                   return (lo < val && val < hi);
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               int lo;
-- line 85 ----------------------------------------
-- line 116 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .                   if (strict)
            .          .          .                      .              .          .                  .                .                .                   {
            .          .          .                      .              .          .                  .                .                .                       for (int r = 0; r < _num; r++) // Look through all intervals
            .          .          .                      .              .          .                  .                .                .                           if (_ranges[r].strictlyin(val))
            .          .          .                      .              .          .                  .                .                .                               return r;
            .          .          .                      .              .          .                  .                .                .                   }
            .          .          .                      .              .          .                  .                .                .                   else
            .          .          .                      .              .          .                  .                .                .                   {
2,009,714,984 (34.69%) 0          0                      4 ( 0.00%)     1 ( 0.00%) 0                  0                0                0                       for (int r = 0; r < _num; r++) // Look through all intervals
  504,951,425 ( 8.72%) 0          0              1,009,072 ( 0.08%)     0          0                  0                0                0                           if (_ranges[r].within(val))
            .          .          .                      .              .          .                  .                .                .                               return r;
            .          .          .                      .              .          .                  .                .                .                   }
            .          .          .                      .              .          .                  .                .                .                   return BADRANGE; // Did not find any range
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               void inspect()
            .          .          .                      .              .          .                  .                .                .               {
            .          .          .                      .              .          .                  .                .                .                   for (int r = 0; r < _num; r++)
-- line 133 ----------------------------------------
-- line 151 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .                   }
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               bool newrange(const Range r)
            .          .          .                      .              .          .                  .                .                .               {                                                                            // Is the range r already in my list, or is it a new one?
            .          .          .                      .              .          .                  .                .                .                   return (range(r.lo, true) == BADRANGE && range(r.hi, true) == BADRANGE); // Overlaps are not allowed.
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           };
    1,009,072 ( 0.02%) 0          0                      0              0          0          1,009,072 ( 1.35%) 126,134 (17.96%) 126,134 (39.15%)      struct Item
            .          .          .                      .              .          .                  .                .                .               {
            .          .          .                      .              .          .                  .                .                .                   int key;
            .          .          .                      .              .          .                  .                .                .                   int value = -1;
            .          .          .                      .              .          .                  .                .                .               };
            .          .          .                      .              .          .                  .                .                .           struct Data
            .          .          .                      .              .          .                  .                .                .           {
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               unsigned int ndata = 0;
            .          .          .                      .              .          .                  .                .                .               Item *data = NULL;
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               Data(int n)
            1 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       1 ( 0.00%)       0               { // n = Maximum number of items  storable
            1 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       0                0                   ndata = n;
    3,027,229 ( 0.05%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0                  2 ( 0.00%)       1 ( 0.00%)       0                   data = new Item[n];
            .          .          .                      .              .          .                  .                .                .                   assert(NULL != data);
            .          .          .                      .              .          .                  .                .                .               }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .               void reset()
            .          .          .                      .              .          .                  .                .                .               {
            .          .          .                      .              .          .                  .                .                .                   for (int i = 0; i < ndata; i++)
            .          .          .                      .              .          .                  .                .                .                       data[i].value = -1;
            .          .          .                      .              .          .                  .                .                .               }
-- line 183 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/A1/classify_v1.cpp
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr                 D1mr             DLmr       Dw                 D1mw             DLmw        

        .          .          .                  .                .          .                  .                .           .           #include "classify_v1.h"
        .          .          .                  .                .          .                  .                .           .           #include <omp.h>
        .          .          .                  .                .          .                  .                .           .           #include <atomic>   
        .          .          .                  .                .          .                  .                .           .           #define STRIDE 10
        .          .          .                  .                .          .                  .                .           .           static std::atomic <int> freq[1001] __attribute__ ((aligned (32))); 
        .          .          .                  .                .          .                  .                .           .           Data classify(Data &D, const Ranges &R, unsigned int numt)
       10 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  8 ( 0.00%)       0           0           { // Classify each item in D into intervals (given by R). Finally, produce in D2 data sorted by interval
        2 ( 0.00%) 0          0                  0                0          0                  0                0           0               assert(numt < MAXTHREADS);
        3 ( 0.00%) 0          0                  2 ( 0.00%)       0          0                  0                0           0               int RLen = R.num();
        2 ( 0.00%) 0          0                  2 ( 0.00%)       0          0                  0                0           0               int nData = D.ndata;
    2,015 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  2 ( 0.00%)       0           0               Counter counts[RLen]; // I need on counter per interval. Each counter can keep pre-thread subcount.
       67 ( 0.00%) 3 ( 0.11%) 3 ( 0.13%)        30 ( 0.00%)      12 ( 0.00%) 0                 21 ( 0.00%)       4 ( 0.00%)  2 ( 0.00%)  #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .               {
        4 ( 0.00%) 0          0                  0                0          0                  4 ( 0.00%)       0           0                   int tid = omp_get_thread_num(); // I am thread number tid
2,018,152 ( 0.03%) 0          0                  0                0          0                  0                0           0                   for (int i = tid; i < nData; i += numt)
        .          .          .                  .                .          .                  .                .           .                   {                                                     // Threads together share-loop through all of Data
4,036,308 ( 0.07%) 1 ( 0.04%) 1 ( 0.04%) 1,009,084 ( 0.08%) 504,542 (55.16%) 0          1,009,072 ( 1.35%)      10 ( 0.00%)  0                       D.data[i].value = R.range(D.data[i].key); // For each data, find the interval of data's key,
        .          .          .                  .                .          .                  .                .           .                                                                         // and store the interval id in value. D is changed.
        .          .          .                  .                .          .                  .                .           .                       // counts[v].increase(tid);                          // Found one key in interval v
        .          .          .                  .                .          .                  .                .           .                   }
        .          .          .                  .                .          .                  .                .           .               }
       70 ( 0.00%) 2 ( 0.07%) 2 ( 0.09%)        33 ( 0.00%)      14 ( 0.00%) 0                 21 ( 0.00%)       4 ( 0.00%)  0           #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .               {
        8 ( 0.00%) 0          0                  0                0          0                  4 ( 0.00%)       0           0                   int tid = omp_get_thread_num(); // I am thread number tid
2,018,188 ( 0.03%) 0          0                  0                0          0                  0                0           0                   for (int i = tid*nData/numt; i <  ((tid + 1) * nData) / numt; i += 1)
        .          .          .                  .                .          .                  .                .           .                   {                                                     // Threads together share-loop through all of Data
       32 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         8 ( 0.00%)       3 ( 0.00%) 0                  0                0           0                       int v = D.data[i].value; // For each data, find the interval of data's key,
        .          .          .                  .                .          .                  .                .           .                                                                         // and store the interval id in value. D is changed.
4,036,288 ( 0.07%) 0          0          2,018,144 ( 0.16%) 127,143 (13.90%) 0                  0                0           0                       counts[v].increase(tid);                          // Found one key in interval v
        .          .          .                  .                .          .                  .                .           .                   }
        .          .          .                  .                .          .                  .                .           .               }
        .          .          .                  .                .          .                  .                .           .           
        .          .          .                  .                .          .                  .                .           .               // Accumulate all sub-counts (in each interval;'s counter) into rangecount
        7 ( 0.00%) 0          0                  2 ( 0.00%)       1 ( 0.00%) 0                  1 ( 0.00%)       0           0               unsigned int *rangecount = new unsigned int[RLen];
        .          .          .                  .                .          .                  .                .           .               //    memset(rangecount,0,sizeof(rangecount));
    2,012 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1 ( 0.00%)       0          0                  0                0           0               for (int r = 0; r < RLen; r++)
        .          .          .                  .                .          .                  .                .           .               { // For all intervals
    1,001 ( 0.00%) 0          0                  0                0          0              1,001 ( 0.00%)      63 ( 0.01%) 62 ( 0.02%)          rangecount[r] = 0;
        .          .          .                  .                .          .                  .                .           .                   freq[r]=0;
   18,018 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)     2,002 ( 0.00%)   1,000 ( 0.11%) 0                  0                0           0                   for (int t = 0; t < numt; t++) // For all threads
    4,004 ( 0.00%) 0          0              4,004 ( 0.00%)       0          0                  0                0           0                       rangecount[r] += counts[r].get(t);
        .          .          .                  .                .          .                  .                .           .                   // std::cout << rangecount[r] << " elements in Range " << r << "\n"; // Debugging statement
        .          .          .                  .                .          .                  .                .           .               }
        .          .          .                  .                .          .                  .                .           .           
        .          .          .                  .                .          .                  .                .           .               // Compute prefx sum on rangecount.
    2,006 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  0                0           0               for (int i = 1; i < RLen; i++)
        .          .          .                  .                .          .                  .                .           .               {
    3,000 ( 0.00%) 0          0              2,000 ( 0.00%)      48 ( 0.01%) 0                  0                0           0                   rangecount[i] += rangecount[i - 1];
        .          .          .                  .                .          .                  .                .           .               }
        .          .          .                  .                .          .                  .                .           .           
        .          .          .                  .                .          .                  .                .           .               // Now rangecount[i] has the number of elements in intervals before the ith interval.
        .          .          .                  .                .          .                  .                .           .           
        .          .          .                  .                .          .                  .                .           .               Data D2 = Data(nData); // Make a copy
        .          .          .                  .                .          .                  .                .           .           
        .          .          .                  .                .          .                  .                .           .           // #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .           //     {
-- line 56 ----------------------------------------
-- line 66 ----------------------------------------
        .          .          .                  .                .          .                  .                .           .           
        .          .          .                  .                .          .                  .                .           .           //                     // rcount++;
        .          .          .                  .                .          .                  .                .           .           //                     D2.data[rangecount[r - 1] + rcount++] = D.data[d]; // Copy it to the appropriate place in D2.
        .          .          .                  .                .          .                  .                .           .           //                                                                        //    D2.data[rangecount[r - 1] + rcount++] = D.data[d]; // Copy it to the appropriate place in D2.
        .          .          .                  .                .          .                  .                .           .           //         } 
        .          .          .                  .                .          .                  .                .           .           //         /// BEST
        .          .          .                  .                .          .                  .                .           .           //     }
        .          .          .                  .                .          .                  .                .           .           
       72 ( 0.00%) 2 ( 0.07%) 2 ( 0.09%)        33 ( 0.00%)       8 ( 0.00%) 0                 22 ( 0.00%)       5 ( 0.00%)  0           #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .               {
        4 ( 0.00%) 0          0                  0                0          0                  4 ( 0.00%)       0           0                   int tid = omp_get_thread_num();
  302,768 ( 0.01%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  0                0           0                    for (uint d = tid * nData / numt; d < ((tid + 1) * nData) / numt; d+=STRIDE) {
3,329,948 ( 0.06%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  0                0           0                         for (uint i = d; i < std::min(d+STRIDE, ((tid + 1) * nData) / numt); i++)                                               
        .          .          .                  .                .          .                  .                .           .                         {                                                                                                                          
4,036,288 ( 0.07%) 1 ( 0.04%) 1 ( 0.04%) 3,027,216 ( 0.24%) 126,138 (13.79%) 0                  0                0           0                             int r = D.data[i].value;                                                                                                
2,018,144 ( 0.03%) 0          0                  0                0          0                  0                0           0                             assert(r > 0);                                                                                                          
8,072,576 ( 0.14%) 0          0          4,036,288 ( 0.32%)      65 ( 0.01%) 0          1,009,072 ( 1.35%) 126,139 (17.96%)  0                             D2.data[rangecount[r-1]+freq[r]++] = D.data[i];                                                                      
        .          .          .                  .                .          .                  .                .           .                         } 
        .          .          .                  .                .          .                  .                .           .                    }
        .          .          .                  .                .          .                  .                .           .                   /// BEST
        .          .          .                  .                .          .                  .                .           .               }
        .          .          .                  .                .          .                  .                .           .           
        2 ( 0.00%) 0          0                  2 ( 0.00%)       0          0                  0                0           0               return D2;
       10 ( 0.00%) 0          0                  7 ( 0.00%)       1 ( 0.00%) 0                  0                0           0           }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/basic_string.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/char_traits.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf

--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                     D1mr             DLmr       Dw                 D1mw             DLmw             
--------------------------------------------------------------------------------
5,070,616,925 (87.52%) 19 ( 0.70%) 19 ( 0.82%) 1,018,997,645 (81.31%) 761,596 (83.26%) 0          4,104,447 ( 5.50%) 255,538 (36.39%) 129,350 (40.14%)  events annotated

