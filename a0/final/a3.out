--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./classify rfile dfile 1009072 4 1
Data file:        cachegrind.out.17774
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Thresholds:       0.1 100 100 100 100 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr           Dr                     D1mr               DLmr            Dw                  D1mw             DLmw             Bc                     Bcm                Bi                 Bim            
--------------------------------------------------------------------------------
5,785,741,109 (100.0%) 2,706 (100.0%) 2,331 (100.0%) 1,253,748,658 (100.0%) 1,299,122 (100.0%) 10,720 (100.0%) 73,100,012 (100.0%) 702,175 (100.0%) 322,201 (100.0%) 1,634,320,130 (100.0%) 3,072,991 (100.0%) 5,073,175 (100.0%) 2,786 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                     D1mr             DLmr           Dw                  D1mw             DLmw             Bc                     Bcm                Bi                 Bim             file:function
--------------------------------------------------------------------------------
5,028,323,750 (86.91%)   0            0          1,006,875,638 (80.31%)     640 ( 0.05%)     0                   0                0                0          1,508,799,843 (92.32%) 1,006,607 (32.76%)         0              0           /home/cse/dual/cs5190421/COL380/a1/final/classify.h:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]
  234,188,449 ( 4.05%)  18 ( 0.67%)  14 ( 0.60%)    55,455,676 ( 4.42%)       8 ( 0.00%)     0          27,066,072 (37.03%)       0                0             37,722,129 ( 2.31%) 1,011,102 (32.90%)         0              0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
  124,914,753 ( 2.16%)   6 ( 0.22%)   5 ( 0.21%)    40,289,597 ( 3.21%)       0              0           6,844,633 ( 9.36%)       0                0             16,723,317 ( 1.02%)        10 ( 0.00%)         0              0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   97,070,475 ( 1.68%)   7 ( 0.26%)   6 ( 0.26%)    52,969,461 ( 4.22%)     336 ( 0.03%)   120 ( 1.12%)  6,845,468 ( 9.36%)       0                0             22,556,043 ( 1.38%)       838 ( 0.03%)       835 ( 0.02%)     1 ( 0.04%)  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   56,001,000 ( 0.97%)   1 ( 0.04%)   1 ( 0.04%)    15,711,408 ( 1.25%)       0              0           1,011,072 ( 1.38%)       0                0             15,711,408 ( 0.96%) 1,011,073 (32.90%)         0              0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   39,432,111 ( 0.68%)   5 ( 0.18%)   5 ( 0.21%)    15,166,099 ( 1.21%)       5 ( 0.00%)     1 ( 0.01%)  6,066,442 ( 8.30%)       0                0              7,077,634 ( 0.43%)        49 ( 0.00%)         0              0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::sentry::sentry(std::istream&, bool)
   34,376,486 ( 0.59%)   3 ( 0.11%)   3 ( 0.13%)    10,110,730 ( 0.81%)       0              0           6,066,440 ( 8.30%) 126,135 (17.96%)       0              4,044,290 ( 0.25%)         8 ( 0.00%)         0              0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::operator>>(int&)
   21,232,533 ( 0.37%)   3 ( 0.11%)   1 ( 0.04%)     9,099,657 ( 0.73%)       8 ( 0.00%)     0           5,055,365 ( 6.92%)       0                0              1,011,073 ( 0.06%)         0                  0              0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::__use_cache<std::__numpunct_cache<char> >::operator()(std::locale const&) const
   15,136,200 ( 0.26%)   3 ( 0.11%)   3 ( 0.13%)     7,063,532 ( 0.56%) 126,211 ( 9.72%)     0           1,009,088 ( 1.38%) 126,145 (17.96%)       0              1,009,076 ( 0.06%)        14 ( 0.00%)         0              0           /home/cse/dual/cs5190421/COL380/a1/final/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.2]
   12,132,864 ( 0.21%)   1 ( 0.04%)   1 ( 0.04%)     4,044,288 ( 0.32%)       2 ( 0.00%)     0           3,033,216 ( 4.15%)       0                0                      0                  0          1,011,072 (19.93%)     1 ( 0.04%)  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istream::operator>>(int&)
   11,122,168 ( 0.19%)   3 ( 0.11%)   2 ( 0.09%)     4,044,542 ( 0.32%)       3 ( 0.00%)     0           1,011,197 ( 1.38%)       0                0              3,033,215 ( 0.19%)       126 ( 0.00%)       126 ( 0.00%)     2 ( 0.07%)  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:std::istream::sentry::sentry(std::istream&, bool)
   11,099,814 ( 0.19%)   2 ( 0.07%)   2 ( 0.09%)     2,018,151 ( 0.16%)       1 ( 0.00%)     0           1,009,078 ( 1.38%)       0                0              1,009,073 ( 0.06%)         2 ( 0.00%)         0              0           /home/cse/dual/cs5190421/COL380/a1/final/main.cpp:readData(char const*, unsigned int)
   11,045,505 ( 0.19%)   7 ( 0.26%)   7 ( 0.30%)     2,504,003 ( 0.20%)       1 ( 0.00%)     1 ( 0.01%)    505,506 ( 0.69%)  61,876 ( 8.81%)  61,876 (19.20%)     3,506,499 ( 0.21%)     5,535 ( 0.18%)         0              0           /home/cse/dual/cs5190421/COL380/a1/final/classify.h:readRanges(char const*)
    9,877,850 ( 0.17%)   1 ( 0.04%)   1 ( 0.04%)             1 ( 0.00%)       0              0           1,011,072 ( 1.38%)       0                0                      0                  0                  0              0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/char_traits.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
    9,081,712 ( 0.16%)   2 ( 0.07%)   2 ( 0.09%)     3,027,252 ( 0.24%) 508,548 (39.15%)     0                  16 ( 0.00%)       2 ( 0.00%)       0              1,009,076 ( 0.06%)        16 ( 0.00%)         0              0           /home/cse/dual/cs5190421/COL380/a1/final/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]
    8,072,644 ( 0.14%)   2 ( 0.07%)   2 ( 0.09%)     1,009,108 ( 0.08%) 504,551 (38.84%)     0           1,009,088 ( 1.38%)      11 ( 0.00%)       2 ( 0.00%)     1,009,076 ( 0.06%)         4 ( 0.00%)         0              0           /home/cse/dual/cs5190421/COL380/a1/final/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]
    7,077,504 ( 0.12%)   3 ( 0.11%)   1 ( 0.04%)     3,033,216 ( 0.24%)       0              0           1,011,072 ( 1.38%)       0                0              1,011,072 ( 0.06%)         0                  0              0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/basic_string.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
    6,054,448 ( 0.10%)   0            0              2,018,144 ( 0.16%)   4,000 ( 0.31%)     0           1,009,072 ( 1.38%)       0                0              1,009,072 ( 0.06%)         1 ( 0.00%)         0              0           /home/cse/dual/cs5190421/COL380/a1/final/classify.h:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/final/classify.cpp
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr                 D1mr             DLmr       Dw                 D1mw             DLmw        Bc                 Bcm         Bi         Bim        

        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           #include "classify.h"
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           #include <omp.h>
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           #include <atomic>
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           Data classify(Data &D, const Ranges &R, unsigned int numt)
        8 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  6 ( 0.00%)       0           0                  0           0          0          0           { // Classify each item in D into intervals (given by R). Finally, produce in D2 data sorted by interval
        2 ( 0.00%) 0          0                  0                0          0                  0                0           0                  1 ( 0.00%)  0          0          0              assert(numt < MAXTHREADS);
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              std::atomic<int> rcountArray [1001];
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              
    3,011 ( 0.00%) 0          0              1,002 ( 0.00%)       0          0                  0                0           0              1,002 ( 0.00%) 10 ( 0.00%) 0          0              for (int r = 0; r < R.num(); r++)
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .               { // For all intervals
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                   rcountArray[r] = 0;
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .               }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
    2,013 ( 0.00%) 0          0                  0                0          0                  1 ( 0.00%)       1 ( 0.00%)  0              1,002 ( 0.00%)  2 ( 0.00%) 0          0              Counter counts[R.num()]; // I need on counter per interval. Each counter can keep pre-thread subcount.
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              // #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              // {
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              //    int tid = omp_get_thread_num(); // I am thread number tid
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              //    for(int i=tid; i<D.ndata; i+=numt) { // Threads together share-loop through all of Data
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              //       int v = D.data[i].value = R.range(D.data[i].key);// For each data, find the interval of data's key,
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           	// 						  // and store the interval id in value. D is changed.
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              //       counts[v].increase(tid); // Found one key in interval v
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              //    }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              // }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           //----------------------------------------------------------------
       44 ( 0.00%) 2 ( 0.07%) 2 ( 0.09%)        20 ( 0.00%)       8 ( 0.00%) 0                 16 ( 0.00%)       2 ( 0.00%)  0                  0           0          0          0              #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              {
        4 ( 0.00%) 0          0                  0                0          0                  4 ( 0.00%)       2 ( 0.00%)  2 ( 0.00%)         0           0          0          0                 int tid = omp_get_thread_num(); // I am thread number tid
4,036,304 ( 0.07%) 0          0                  8 ( 0.00%)       5 ( 0.00%) 0                  0                0           0          1,009,076 ( 0.06%)  4 ( 0.00%) 0          0                 for(int i=tid; i<D.ndata; i+=numt) { // Threads together share-loop through all of Data
4,036,300 ( 0.07%) 1 ( 0.04%) 1 ( 0.04%) 1,009,080 ( 0.08%) 504,538 (38.84%) 0          1,009,072 ( 1.38%)       9 ( 0.00%)  0                  0           0          0          0                     D.data[i].value = R.range(D.data[i].key);// For each data, find the interval of data's key,
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           							  // and store the interval id in value. D is changed.
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                    // counts[v].increase(tid); // Found one key in interval v
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              }
       49 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)        25 ( 0.00%)      11 ( 0.00%) 0                 16 ( 0.00%)       1 ( 0.00%)  0                  0           0          0          0               #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              {
        4 ( 0.00%) 0          0                  0                0          0                  4 ( 0.00%)       2 ( 0.00%)  0                  0           0          0          0                 int tid = omp_get_thread_num(); // I am thread number tid
4,036,300 ( 0.07%) 0          0          1,009,080 ( 0.08%)       0          0                  0                0           0          1,009,076 ( 0.06%) 16 ( 0.00%) 0          0                 for(int i=tid; i<D.ndata; i+=numt) { // Threads together share-loop through all of Data
1,009,080 ( 0.02%) 0          0                  4 ( 0.00%)       0          0                  0                0           0                  0           0          0          0                    int v = D.data[i].value;// = R.range(D.data[i].key);// For each data, find the interval of data's key,
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           							  // and store the interval id in value. D is changed.
4,036,288 ( 0.07%) 1 ( 0.04%) 1 ( 0.04%) 2,018,144 ( 0.16%) 508,538 (39.14%) 0                  0                0           0                  0           0          0          0                    counts[v].increase(tid); // Found one key in interval v
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           //----------------------------------------------------------------
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              // Accumulate all sub-counts (in each interval;'s counter) into rangecount
        7 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1 ( 0.00%)       0          0                  1 ( 0.00%)       0           0                  1 ( 0.00%)  0          0          0              unsigned int *rangecount = new unsigned int[R.num()];
    2,011 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         2 ( 0.00%)       1 ( 0.00%) 0                  0                0           0              1,002 ( 0.00%)  2 ( 0.00%) 0          0              for(int r=0; r<R.num(); r++) { // For all intervals
    1,001 ( 0.00%) 0          0                  0                0          0              1,001 ( 0.00%)      63 ( 0.01%) 62 ( 0.02%)         0           0          0          0                 rangecount[r] = 0;
   15,015 ( 0.00%) 0          0              2,002 ( 0.00%)   1,001 ( 0.08%) 0                  0                0           0              5,005 ( 0.00%)  7 ( 0.00%) 0          0                 for(int t=0; t<numt; t++) // For all threads
    4,004 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)     4,004 ( 0.00%)       0          0                  0                0           0                  0           0          0          0                    rangecount[r] += counts[r].get(t);
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 // std::cout << rangecount[r] << " elements in Range " << r << "\n"; // Debugging statement
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              // Compute prefx sum on rangecount.
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              for(int i=1; i<R.num(); i++) {
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 rangecount[i] += rangecount[i-1];
    2,006 ( 0.00%) 0          0                  0                0          0                  0                0           0              1,001 ( 0.00%)  8 ( 0.00%) 0          0              }
    2,000 ( 0.00%) 0          0              2,000 ( 0.00%)      48 ( 0.00%) 0                  0                0           0                  0           0          0          0           
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              // Now rangecount[i] has the number of elements in intervals before the ith interval.
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              Data D2 = Data(D.ndata); // Make a copy
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              
        1 ( 0.00%) 0          0                  1 ( 0.00%)       1 ( 0.00%) 0                  0                0           0                  0           0          0          0              #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              {
       52 ( 0.00%) 2 ( 0.07%) 2 ( 0.09%)        24 ( 0.00%)       4 ( 0.00%) 0                 18 ( 0.00%)       2 ( 0.00%)  0                  0           0          0          0           //----------------------------------------------------------------
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 // int tid = omp_get_thread_num();
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 // for(int r=tid; r<R.num(); r+=numt) { // Thread together share-loop through the intervals 
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 //    int rcount = 0;
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 //    for(int d=0; d<D.ndata; d++) // For each interval, thread loops through all of data and  
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 //        if(D.data[d].value == r) // If the data item is in this interval 
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 //            D2.data[rangecount[r-1]+rcount++] = D.data[d]; // Copy it to the appropriate place in D2.
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 // }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           //----------------------------------------------------------------
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 int tid=omp_get_thread_num();
        4 ( 0.00%) 0          0                  0                0          0                  4 ( 0.00%)       3 ( 0.00%)  0                  0           0          0          0                 int start=tid*D.ndata/numt, end= std::min(((tid + 1) * D.ndata) / numt,D.ndata);
       48 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         8 ( 0.00%)       1 ( 0.00%) 0                  0                0           0                  0           0          0          0                 for(int d=start;d<end;d++){
4,036,316 ( 0.07%) 0          0          1,009,068 ( 0.08%)       0          0                  0                0           0          1,009,076 ( 0.06%) 14 ( 0.00%) 0          0                    int r=D.data[d].value;
3,027,216 ( 0.05%) 1 ( 0.04%) 1 ( 0.04%) 1,009,072 ( 0.08%)       0          0                  0                0           0                  0           0          0          0                    D2.data[rangecount[r-1]+rcountArray[r]++]=D.data[d];
8,072,576 ( 0.14%) 0          0          5,045,360 ( 0.40%) 126,206 ( 9.71%) 0          1,009,072 ( 1.38%) 126,142 (17.96%)  0                  0           0          0          0                 }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              return D2;
        2 ( 0.00%) 0          0                  2 ( 0.00%)       0          0                  0                0           0                  0           0          0          0           }
       10 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         7 ( 0.00%)       1 ( 0.00%) 0                  0                0           0                  0           0          0          0           <bogus line 83>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@
@@ Information recorded about lines past the end of '/home/cse/dual/cs5190421/COL380/a1/final/classify.cpp'.
@@
@@ Probable cause and solution:
@@ cause:    not sure, sorry
@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/final/main.cpp
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr                 D1mr             DLmr       Dw                 D1mw       DLmw       Bc                 Bcm         Bi         Bim        

        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           #include <unistd.h>
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           #include <iostream>
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           #include <fstream>
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           #include <chrono>
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           #include "classify.h"
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           float timedwork(Data &D, const Ranges &R, unsigned int numt)
        8 ( 0.00%) 1 ( 0.04%) 0                  0                0          0                  5 ( 0.00%) 0          0                  0           0          0          0           {
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              // starttimer();
        2 ( 0.00%) 0          0                  0                0          0                  1 ( 0.00%) 0          0                  0           0          0          0              auto begin = std::chrono::high_resolution_clock::now();
        6 ( 0.00%) 0          0                  0                0          0                  1 ( 0.00%) 0          0                  0           0          0          0              Data D2 = classify(D, R, numt);
        1 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  1 ( 0.00%) 0          0                  0           0          0          0              auto end = std::chrono::high_resolution_clock::now();
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              // return(1e-6 * elapsed.count());
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              // bool sorted=false;for(int i=0;i<D.ndata-1;i++){if(D.data[i].value>D.data[i+1].value)sorted=true;} std::cout << "sorted: " << sorted << std::endl;
2,774,989 ( 0.05%) 3 ( 0.11%) 3 ( 0.13%) 1,009,072 ( 0.08%) 126,135 ( 9.71%) 0                  0          0          0            252,272 ( 0.02%) 12 ( 0.00%) 0          0              int sorted = 0;for(int i = 1; i < D2.ndata; i++){if (D2.data[i-1].value > D2.data[i].value)sorted ++;}std::cout << "Is sorted? " << std::boolalpha << (sorted == 0) << std::endl;
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        4 ( 0.00%) 0          0                  1 ( 0.00%)       1 ( 0.00%) 0                  0          0          0                  0           0          0          0              return(1e-6 * (std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin)).count());
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              // return mssince();
        6 ( 0.00%) 0          0                  6 ( 0.00%)       0          0                  0          0          0                  0           0          0          0           }
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           void repeatrun(unsigned int reps, Data &D, const Ranges &R, unsigned int numt)
       10 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  5 ( 0.00%) 0          0                  0           0          0          0           { // Repeat the same experiment. Time each rep. D, R, and numt remain fixed.
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              int it;
        5 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1 ( 0.00%)       0          0                  2 ( 0.00%) 0          0                  0           0          0          0              float ms, tms = 0, minms = 1e7;
        6 ( 0.00%) 0          0                  0                0          0                  0          0          0                  2 ( 0.00%)  0          0          0              for(it=0; it<reps; it++) {
        8 ( 0.00%) 0          0                  1 ( 0.00%)       1 ( 0.00%) 0                  2 ( 0.00%) 0          0                  0           0          0          0                 tms += ms = timedwork(D, R, numt); // This is the real work
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .                 std::cout << ms << " ms\n";
        2 ( 0.00%) 0          0                  0                0          0                  1 ( 0.00%) 0          0                  0           0          0          0                 usleep(1000); // Lose control for 1 ms 
        3 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         2 ( 0.00%)       0          0                  1 ( 0.00%) 0          0                  0           0          0          0                 if(ms < minms) minms = ms;
        1 ( 0.00%) 0          0                  1 ( 0.00%)       1 ( 0.00%) 0                  0          0          0                  0           0          0          0                 D.reset();
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              }
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              std::cout << reps << " iterations of " << D.ndata << " items in " 
        4 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1 ( 0.00%)       0          0                  1 ( 0.00%) 0          0                  0           0          0          0                        << R.num() << " ranges with " << numt << " threads: Fastest took "
        4 ( 0.00%) 0          0                  1 ( 0.00%)       0          0                  0          0          0                  0           0          0          0                        << minms << " ms, Average was " << tms/reps << " ms\n";
        6 ( 0.00%) 0          0                  5 ( 0.00%)       0          0                  0          0          0                  0           0          0          0           }
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           Ranges readRanges(const char *filename)
        8 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  6 ( 0.00%) 0          0                  0           0          0          0           {
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               Ranges R;
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               std::fstream fs(filename, std::fstream::in);
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               int lo, hi;
  510,509 ( 0.01%) 0          0              2,002 ( 0.00%)       0          0              2,002 ( 0.00%) 0          0              1,001 ( 0.00%)  1 ( 0.00%) 0          0               while (fs >> lo >> hi)
    5,000 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)     2,000 ( 0.00%)       0          0                  0          0          0                  0           0          0          0                   R += Range(lo, hi);
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               fs.close();
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        1 ( 0.00%) 0          0                  0                0          0                  0          0          0                  0           0          0          0               return R;
       14 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         7 ( 0.00%)       1 ( 0.00%) 0                  0          0          0                  0           0          0          0           }
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           Data readData(const char *filename, unsigned int nItems)
        8 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  6 ( 0.00%) 0          0                  0           0          0          0           {
        2 ( 0.00%) 0          0                  0                0          0                  0          0          0                  1 ( 0.00%)  0          0          0               assert(nItems > 0);
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               Data D(nItems);
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               std::fstream fs(filename, std::fstream::in);
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               int d = 0;
8,072,576 ( 0.14%) 0          0          2,018,144 ( 0.16%)       0          0          1,009,072 ( 1.38%) 0          0                  0           0          0          0               while (fs >> D.data[d++].key)
3,027,216 ( 0.05%) 0          0                  0                0          0                  0          0          0          1,009,072 ( 0.06%)  2 ( 0.00%) 0          0                  if(d == nItems)
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .                     break;
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               if(d < nItems)
        2 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  0          0          0                  0           0          0          0                  D.ndata = d-1;
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               fs.close();
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .               return D;
       10 ( 0.00%) 0          0                  7 ( 0.00%)       1 ( 0.00%) 0                  0          0          0                  0           0          0          0           }
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           int main(int argc, char *argv[])
        4 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0                  3 ( 0.00%) 0          0                  0           0          0          0           {
        3 ( 0.00%) 0          0                  0                0          0                  0          0          0                  1 ( 0.00%)  1 ( 0.00%) 0          0              assert(argc > 4); // <rangefile> <datafile> <max data to read> <number of threads to use>
        6 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1 ( 0.00%)       1 ( 0.00%) 0                  3 ( 0.00%) 1 ( 0.00%) 0                  0           0          0          0              Ranges R = readRanges(argv[1]);
        4 ( 0.00%) 0          0                  1 ( 0.00%)       0          0                  3 ( 0.00%) 1 ( 0.00%) 0                  0           0          0          0              Data D = readData(argv[2], atoi(argv[3]));
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              int reps = 6; // 6 reps by default
        2 ( 0.00%) 0          0                  0                0          0                  0          0          0                  1 ( 0.00%)  1 ( 0.00%) 0          0              if(argc == 6) // If there is a reps arg, use it
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .                 reps = atoi(argv[5]);
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .           
        4 ( 0.00%) 0          0                  0                0          0                  1 ( 0.00%) 0          0                  0           0          0          0              repeatrun(reps, D, R, atoi(argv[4])); // repeat reps times
        .          .          .                  .                .          .                  .          .          .                  .           .          .          .              return 0;
        8 ( 0.00%) 3 ( 0.11%) 1 ( 0.04%)         4 ( 0.00%)       0          0                  0          0          0                  0           0          0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/final/classify.h
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr           DLmr       Dw                 D1mw             DLmw             Bc                     Bcm                Bi         Bim        

-- line 11 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           class Ranges;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           Data classify(Data &D, const Ranges &R, unsigned int numt);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           class alignas(32) Counter { // Aligned allocation per counter. Is that enough?
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           			    // Keeps per-thread subcount.
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           public:
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Counter(unsigned int num=MAXTHREADS) {
        1,001 ( 0.00%) 0          0                      0              0          0              1,001 ( 0.00%)       0                0                      0                  0          0          0                 _numcount = num;
        3,003 ( 0.00%) 0          0                      0              0          0              2,002 ( 0.00%)       1 ( 0.00%)       1 ( 0.00%)             0                  0          0          0                 _counts = new unsigned int[num];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 assert(_counts != NULL);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 zero();
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void zero() { // Initialize
      135,135 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1,001 ( 0.00%)     0          0                  0                0                0                 65,065 ( 0.00%)     1,012 ( 0.03%) 0          0                 for(int i=0; i<_numcount; i++)
      128,128 ( 0.00%) 0          0                      0              0          0             64,064 ( 0.09%)   3,185 ( 0.45%)   3,151 ( 0.98%)             0                  0          0          0           	 _counts[i] = 0;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void increase(unsigned int id) { // If each sub-counter belongs to a thread mutual exclusion is not needed
    2,018,144 ( 0.03%) 0          0              1,009,072 ( 0.08%)     0          0                  0                0                0              1,009,072 ( 0.06%)         1 ( 0.00%) 0          0                 assert(id < _numcount);
    4,036,304 ( 0.07%) 0          0              1,009,072 ( 0.08%) 4,000 ( 0.31%) 0          1,009,072 ( 1.38%)       0                0                      0                  0          0          0                 _counts[id]++;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void xincrease(unsigned int id) { // Safe increment
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 assert(id < _numcount);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 const std::lock_guard<std::mutex> lock(cmutex);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 _counts[id]++;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned int get(unsigned int id) const { // return subcounter value for specific thread
        8,008 ( 0.00%) 0          0                      0              0          0                  0                0                0                  4,004 ( 0.00%)         3 ( 0.00%) 0          0                 assert(id < _numcount);
        8,008 ( 0.00%) 0          0                  4,004 ( 0.00%) 1,001 ( 0.08%) 0                  0                0                0                      0                  0          0          0                 return _counts[id];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void inspect() {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 std::cout << "Subcounts -- ";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 for(int i=0; i<_numcount; i++)
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           	 std::cout << i << ":" << _counts[i] << " ";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 std::cout << "\n";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
-- line 51 ----------------------------------------
-- line 54 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned volatile int *_counts;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned int _numcount; // Per-thread subcounts 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              std::mutex cmutex;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           struct Range { // Integer range
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Range(int a=1, int b=0) { // Constructor. Defaults to *bad* range
    1,258,001 ( 0.02%) 1 ( 0.04%) 1 ( 0.04%)       250,500 ( 0.02%)     1 ( 0.00%) 1 ( 0.01%)   251,001 ( 0.34%)  61,876 ( 8.81%)  61,876 (19.20%)       251,500 ( 0.02%)     1,997 ( 0.06%) 0          0                 lo = a;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 hi = b;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              bool within(int val) const { // Return if val is within this range
2,513,657,333 (43.45%) 0          0          1,005,866,562 (80.23%)   640 ( 0.05%) 0                  0                0                0          1,005,866,562 (61.55%) 1,006,607 (32.76%) 0          0                  return(lo <= val && val <= hi);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              bool strictlyin(int val) const { // Return if val is strictly inside this range
    4,003,998 ( 0.07%) 0          0              2,001,999 ( 0.16%)     0          0                  0                0                0              2,001,999 ( 0.12%)        14 ( 0.00%) 0          0                  return(lo < val && val < hi);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int lo;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int hi; 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           class Ranges {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           public:
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Ranges() { // Initialize with a single unreal interval
            2 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0                  0                0                0                      0                  0          0          0                 _num = 1;
            3 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0                  1 ( 0.00%)       0                0                      0                  0          0          0                 _ranges = new Range(1, 0); // Started with this. Its not a real interval as nothing lies inside it.
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Ranges& operator+=(const Range range){ // Add one more interval to this list
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 if(newrange(range)) { // If it already exists, do not add
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    Range *oranges = _ranges;
       12,000 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0              2,000 ( 0.00%)       0                0                      0                  0          0          0                    _ranges = new Range[_num+1];
       10,990 ( 0.00%) 0          0                      0              0          0                  0                0                0                  1,000 ( 0.00%)         2 ( 0.00%) 0          0                    assert(NULL != _ranges);
            8 ( 0.00%) 0          0                      0              0          0                  0                0                0                      3 ( 0.00%)         1 ( 0.00%) 0          0                    for(int r=0; r<_num; r++) { 
          505 ( 0.00%) 0          0                    505 ( 0.00%)     0          0                  0                0                0                      0                  0          0          0                       set(r, oranges[r].lo, oranges[r].hi); // copy old intervals
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    set(_num++, range.lo, range.hi); // Add the new interval at the end
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 return *this;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int range(int val, bool strict = false) const { // Tell the range in which val lies (strict => boundary match not ok)
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  if(strict) {
    4,500,500 ( 0.08%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0                  0                0                0              1,001,000 ( 0.06%)     2,001 ( 0.07%) 0          0                     for(int r=0; r<_num; r++) // Look through all intervals
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                        if(_ranges[r].strictlyin(val))
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                           return r;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  } else {
2,009,714,992 (34.74%) 0          0                      4 ( 0.00%)     0          0                  0                0                0            502,933,281 (30.77%)         0          0          0                     for(int r=0; r<_num; r++) // Look through all intervals
  504,951,425 ( 8.73%) 0          0              1,009,072 ( 0.08%)     0          0                  0                0                0                      0                  0          0          0                        if(_ranges[r].within(val))
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                           return r;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  return BADRANGE; // Did not find any range
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void inspect() {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 for(int r=0; r<_num; r++) { 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    std::cout << r << "," << &_ranges[r] << ": " << _ranges[r].lo << ", " << _ranges[r].hi << "\n"; 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
        3,002 ( 0.00%) 0          0                      0              0          0                  0                0                0                      0                  0          0          0              int num() const { return _num; }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           private:
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Range *_ranges;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int   _num;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void set(int i, int lo, int hi) { // set the extreme values of a specific interval
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 if(i < _num) {
    1,256,489 ( 0.02%) 2 ( 0.07%) 2 ( 0.09%)       249,999 ( 0.02%)     0          0            251,501 ( 0.34%)       0                0                250,997 ( 0.02%)     1,520 ( 0.05%) 0          0                     _ranges[i].lo = lo;
        1,009 ( 0.00%) 0          0                      0              0          0              1,003 ( 0.00%)       0                0                      0                  0          0          0                     _ranges[i].hi = hi;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 }
        1,000 ( 0.00%) 0          0                  1,000 ( 0.00%)     0          0                  0                0                0                      0                  0          0          0              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              bool newrange(const Range r) { // Is the range r already in my list, or is it a new one?
        1,000 ( 0.00%) 0          0                      0              0          0                  0                0                0                      0                  0          0          0                 return (range(r.lo, true) == BADRANGE && range(r.hi, true) == BADRANGE); // Overlaps are not allowed.
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           struct Data {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
    3,027,216 ( 0.05%) 0          0                      0              0          0          2,018,144 ( 2.76%) 252,268 (35.93%) 252,268 (78.30%)             0                  0          0          0              struct Item {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 int key;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 int value = -1;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned int ndata = 0;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Item *data = NULL;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            1 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       1 ( 0.00%)       0                      0                  0          0          0              Data(int n) { // n = Maximum number of items  storable
            1 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       0                0                      0                  0          0          0                 ndata = n;
    5,045,385 ( 0.09%) 3 ( 0.11%) 3 ( 0.13%)             0              0          0                  3 ( 0.00%)       2 ( 0.00%)       0              2,018,147 ( 0.12%)        14 ( 0.00%) 0          0                 data = new Item[n];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 assert(NULL != data);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void reset() {
    2,018,146 ( 0.03%) 0          0                      0              0          0                  0                0                0              1,009,073 ( 0.06%)        16 ( 0.00%) 0          0                 for(int i=0; i<ndata; i++)
    2,018,149 ( 0.03%) 0          0                      1 ( 0.00%)     0          0          1,009,072 ( 1.38%) 126,135 (17.96%)       0                      0                  0          0          0                    data[i].value = -1;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void inspect() {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 for(int i=0; i<ndata; i++)
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    std::cout << i << ": " << data[i].key << " -- " << data[i].value <<"\n";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/basic_string.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/char_traits.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf

--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                     D1mr               DLmr       Dw                 D1mw             DLmw             Bc                     Bcm                Bi         Bim        
--------------------------------------------------------------------------------
5,104,530,994 (88.23%) 43 ( 1.59%) 40 ( 1.72%) 1,025,542,955 (81.80%) 1,272,145 (97.92%) 1 ( 0.01%) 7,639,197 (10.45%) 569,697 (81.13%) 317,360 (98.50%) 1,520,710,295 (93.05%) 1,013,268 (32.97%) 0          0           events annotated

