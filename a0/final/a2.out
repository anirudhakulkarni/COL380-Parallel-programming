--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./classify rfile dfile 1009072 4 1
Data file:        cachegrind.out.20625
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Thresholds:       0.1 100 100 100 100 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr           Dr                     D1mr             DLmr            Dw                  D1mw             DLmw             Bc                     Bcm                Bi                 Bim          
--------------------------------------------------------------------------------
5,782,883,471 (100.0%) 2,654 (100.0%) 2,306 (100.0%) 1,253,229,877 (100.0%) 668,760 (100.0%) 10,709 (100.0%) 74,598,105 (100.0%) 702,130 (100.0%) 322,215 (100.0%) 1,633,551,431 (100.0%) 3,070,801 (100.0%) 5,073,129 (100.0%) 848 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                     D1mr             DLmr           Dw                  D1mw             DLmw             Bc                     Bcm                Bi                 Bim           file:function
--------------------------------------------------------------------------------
5,038,414,474 (87.13%)   0            0          1,009,902,850 (80.58%)   5,148 ( 0.77%)     0           1,009,072 ( 1.35%)       0                0          1,509,808,915 (92.42%) 1,006,604 (32.78%)         0            0           /home/cse/dual/cs5190421/COL380/a1/final/classify.h:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]
  234,188,449 ( 4.05%)  19 ( 0.72%)  14 ( 0.61%)    55,455,676 ( 4.43%)       8 ( 0.00%)     0          27,066,072 (36.28%)       0                0             37,722,129 ( 2.31%) 1,011,102 (32.93%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
  124,914,753 ( 2.16%)   6 ( 0.23%)   5 ( 0.22%)    40,289,597 ( 3.21%)       0              0           6,844,633 ( 9.18%)       0                0             16,723,317 ( 1.02%)        10 ( 0.00%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   97,070,475 ( 1.68%)   7 ( 0.26%)   6 ( 0.26%)    52,969,461 ( 4.23%)     336 ( 0.05%)   120 ( 1.12%)  6,845,468 ( 9.18%)       0                0             22,556,043 ( 1.38%)       838 ( 0.03%)       835 ( 0.02%)   1 ( 0.12%)  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   56,001,000 ( 0.97%)   1 ( 0.04%)   1 ( 0.04%)    15,711,408 ( 1.25%)       0              0           1,011,072 ( 1.36%)       0                0             15,711,408 ( 0.96%) 1,011,073 (32.93%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   39,432,111 ( 0.68%)   5 ( 0.19%)   5 ( 0.22%)    15,166,099 ( 1.21%)       5 ( 0.00%)     1 ( 0.01%)  6,066,442 ( 8.13%)       0                0              7,077,634 ( 0.43%)        40 ( 0.00%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::sentry::sentry(std::istream&, bool)
   34,376,486 ( 0.59%)   4 ( 0.15%)   3 ( 0.13%)    10,110,730 ( 0.81%)       0              0           6,066,440 ( 8.13%) 126,135 (17.96%)       0              4,044,290 ( 0.25%)         8 ( 0.00%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::operator>>(int&)
   21,232,512 ( 0.37%)   2 ( 0.08%)   1 ( 0.04%)     9,099,648 ( 0.73%)       4 ( 0.00%)     0           5,055,360 ( 6.78%)       0                0              1,011,072 ( 0.06%)         0                  0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::__use_cache<std::__numpunct_cache<char> >::operator()(std::locale const&) const
   15,136,200 ( 0.26%)   3 ( 0.11%)   3 ( 0.13%)     7,063,532 ( 0.56%) 126,209 (18.87%)     0           1,009,088 ( 1.35%) 126,144 (17.97%)       0              1,009,076 ( 0.06%)        11 ( 0.00%)         0            0           /home/cse/dual/cs5190421/COL380/a1/final/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]
   15,033,003 ( 0.26%)   4 ( 0.15%)   4 ( 0.17%)     3,003,999 ( 0.24%)       0              0           2,008,002 ( 2.69%)  61,876 ( 8.81%)  61,876 (19.20%)     4,004,999 ( 0.25%)     4,039 ( 0.13%)         0            0           /home/cse/dual/cs5190421/COL380/a1/final/classify.h:readRanges(char const*)
   12,132,864 ( 0.21%)   1 ( 0.04%)   1 ( 0.04%)     4,044,288 ( 0.32%)       1 ( 0.00%)     0           3,033,216 ( 4.07%)       0                0                      0                  0          1,011,072 (19.93%)   1 ( 0.12%)  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istream::operator>>(int&)
   11,122,168 ( 0.19%)   3 ( 0.11%)   2 ( 0.09%)     4,044,542 ( 0.32%)       3 ( 0.00%)     0           1,011,197 ( 1.36%)       0                0              3,033,215 ( 0.19%)       126 ( 0.00%)       126 ( 0.00%)   2 ( 0.24%)  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:std::istream::sentry::sentry(std::istream&, bool)
   11,099,814 ( 0.19%)   1 ( 0.04%)   1 ( 0.04%)     2,018,151 ( 0.16%)       1 ( 0.00%)     0           1,009,078 ( 1.35%)       0                0              1,009,073 ( 0.06%)         1 ( 0.00%)         0            0           /home/cse/dual/cs5190421/COL380/a1/final/main.cpp:readData(char const*, unsigned int)
    9,877,850 ( 0.17%)   1 ( 0.04%)   1 ( 0.04%)             1 ( 0.00%)       0              0           1,011,072 ( 1.36%)       0                0                      0                  0                  0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/char_traits.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
    9,081,732 ( 0.16%)   3 ( 0.11%)   3 ( 0.13%)     3,027,264 ( 0.24%) 508,600 (76.05%)     0           1,009,096 ( 1.35%)      53 ( 0.01%)       2 ( 0.00%)     1,009,076 ( 0.06%)         4 ( 0.00%)         0            0           /home/cse/dual/cs5190421/COL380/a1/final/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]
    7,077,504 ( 0.12%)   3 ( 0.11%)   1 ( 0.04%)     3,033,216 ( 0.24%)       0              0           1,011,072 ( 1.36%)       0                0              1,011,072 ( 0.06%)         0                  0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/basic_string.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/final/classify.cpp
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr                 D1mr             DLmr       Dw                 D1mw             DLmw        Bc                 Bcm         Bi         Bim        

        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           #include "classify.h"
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           #include <omp.h>
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           #include <atomic>
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           Data classify(Data &D, const Ranges &R, unsigned int numt)
        9 ( 0.00%) 2 ( 0.08%) 2 ( 0.09%)         0                0          0                  7 ( 0.00%)       1 ( 0.00%)  0                  0           0          0          0           { // Classify each item in D into intervals (given by R). Finally, produce in D2 data sorted by interval
        2 ( 0.00%) 0          0                  0                0          0                  0                0           0                  1 ( 0.00%)  0          0          0              assert(numt < MAXTHREADS);
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              std::atomic<int> rcountArray [1001];
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              
    3,010 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)     1,002 ( 0.00%)       0          0                  0                0           0              1,002 ( 0.00%) 10 ( 0.00%) 0          0              for (int r = 0; r < R.num(); r++)
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .               { // For all intervals
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                   rcountArray[r] = 0;
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .               }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
    2,013 ( 0.00%) 0          0                  0                0          0                  0                0           0              1,002 ( 0.00%)  3 ( 0.00%) 0          0              Counter counts[R.num()]; // I need on counter per interval. Each counter can keep pre-thread subcount.
       66 ( 0.00%) 2 ( 0.08%) 2 ( 0.09%)        33 ( 0.00%)      12 ( 0.00%) 0                 25 ( 0.00%)       4 ( 0.00%)  2 ( 0.00%)         0           0          0          0              #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              {
        4 ( 0.00%) 0          0                  0                0          0                  4 ( 0.00%)       0           0                  0           0          0          0                 int tid = omp_get_thread_num(); // I am thread number tid
4,036,300 ( 0.07%) 0          0          1,009,080 ( 0.08%)       1 ( 0.00%) 0                  0                0           0          1,009,076 ( 0.06%)  4 ( 0.00%) 0          0                 for(int i=tid; i<D.ndata; i+=numt) { // Threads together share-loop through all of Data
4,036,300 ( 0.07%) 2 ( 0.08%) 2 ( 0.09%) 1,009,080 ( 0.08%) 504,538 (75.44%) 0          1,009,072 ( 1.35%)      50 ( 0.01%)  0                  0           0          0          0                    int v = D.data[i].value = R.range(D.data[i].key);// For each data, find the interval of data's key,
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           							  // and store the interval id in value. D is changed.
1,009,072 ( 0.02%) 0          0          1,009,072 ( 0.08%)   4,049 ( 0.61%) 0                  0                0           0                  0           0          0          0                    counts[v].increase(tid); // Found one key in interval v
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              // Accumulate all sub-counts (in each interval;'s counter) into rangecount
        7 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1 ( 0.00%)       0          0                  1 ( 0.00%)       0           0                  1 ( 0.00%)  0          0          0              unsigned int *rangecount = new unsigned int[R.num()];
    2,011 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1 ( 0.00%)       0          0                  0                0           0              1,002 ( 0.00%)  3 ( 0.00%) 0          0              for(int r=0; r<R.num(); r++) { // For all intervals
    1,001 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0                0          0              1,001 ( 0.00%)      63 ( 0.01%) 62 ( 0.02%)         0           0          0          0                 rangecount[r] = 0;
   15,015 ( 0.00%) 0          0              2,002 ( 0.00%)   1,000 ( 0.15%) 0                  0                0           0              5,005 ( 0.00%)  6 ( 0.00%) 0          0                 for(int t=0; t<numt; t++) // For all threads
    4,004 ( 0.00%) 0          0              4,004 ( 0.00%)       0          0                  0                0           0                  0           0          0          0                    rangecount[r] += counts[r].get(t);
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 // std::cout << rangecount[r] << " elements in Range " << r << "\n"; // Debugging statement
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              // Compute prefx sum on rangecount.
    2,006 ( 0.00%) 0          0                  0                0          0                  0                0           0              1,001 ( 0.00%)  8 ( 0.00%) 0          0              for(int i=1; i<R.num(); i++) {
    2,000 ( 0.00%) 0          0              2,000 ( 0.00%)      48 ( 0.01%) 0                  0                0           0                  0           0          0          0                 rangecount[i] += rangecount[i-1];
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              // Now rangecount[i] has the number of elements in intervals before the ith interval.
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
        2 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         2 ( 0.00%)       2 ( 0.00%) 0                  0                0           0                  0           0          0          0              Data D2 = Data(D.ndata); // Make a copy
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              
       53 ( 0.00%) 2 ( 0.08%) 2 ( 0.09%)        25 ( 0.00%)       5 ( 0.00%) 0                 18 ( 0.00%)       1 ( 0.00%)  0                  0           0          0          0              #pragma omp parallel num_threads(numt)
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              {
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 // int tid = omp_get_thread_num();
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 // for(int r=tid; r<R.num(); r+=numt) { // Thread together share-loop through the intervals 
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 //    int rcount = 0;
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 //    for(int d=0; d<D.ndata; d++) // For each interval, thread loops through all of data and  
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 //        if(D.data[d].value == r) // If the data item is in this interval 
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 //            D2.data[rangecount[r-1]+rcount++] = D.data[d]; // Copy it to the appropriate place in D2.
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 // }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
        4 ( 0.00%) 0          0                  0                0          0                  4 ( 0.00%)       2 ( 0.00%)  0                  0           0          0          0                 int tid=omp_get_thread_num();
       48 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         8 ( 0.00%)       1 ( 0.00%) 0                  0                0           0                  0           0          0          0                 int start=tid*D.ndata/numt, end= std::min(((tid + 1) * D.ndata) / numt,D.ndata);
4,036,316 ( 0.07%) 0          0          1,009,068 ( 0.08%)       0          0                  0                0           0          1,009,076 ( 0.06%) 11 ( 0.00%) 0          0                 for(int d=start;d<end;d++){
3,027,216 ( 0.05%) 1 ( 0.04%) 1 ( 0.04%) 1,009,072 ( 0.08%)       0          0                  0                0           0                  0           0          0          0                    int r=D.data[d].value;
8,072,576 ( 0.14%) 0          0          5,045,360 ( 0.40%) 126,204 (18.87%) 0          1,009,072 ( 1.35%) 126,142 (17.97%)  0                  0           0          0          0                    D2.data[rangecount[r-1]+rcountArray[r]++]=D.data[d];
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .                 }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .              }
        .          .          .                  .                .          .                  .                .           .                  .           .          .          .           
        2 ( 0.00%) 0          0                  2 ( 0.00%)       0          0                  0                0           0                  0           0          0          0              return D2;
       10 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         7 ( 0.00%)       2 ( 0.00%) 0                  0                0           0                  0           0          0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/final/classify.h
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr           DLmr       Dw                 D1mw             DLmw             Bc                     Bcm                Bi         Bim        

-- line 11 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           class Ranges;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           Data classify(Data &D, const Ranges &R, unsigned int numt);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           class alignas(32) Counter { // Aligned allocation per counter. Is that enough?
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           			    // Keeps per-thread subcount.
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           public:
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Counter(unsigned int num=MAXTHREADS) {
        1,001 ( 0.00%) 0          0                      0              0          0              1,001 ( 0.00%)       1 ( 0.00%)       1 ( 0.00%)             0                  0          0          0                 _numcount = num;
        3,003 ( 0.00%) 0          0                      0              0          0              2,002 ( 0.00%)       0                0                      0                  0          0          0                 _counts = new unsigned int[num];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 assert(_counts != NULL);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 zero();
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void zero() { // Initialize
      135,135 ( 0.00%) 0          0                  1,001 ( 0.00%)     0          0                  0                0                0                 65,065 ( 0.00%)     1,006 ( 0.03%) 0          0                 for(int i=0; i<_numcount; i++)
      128,128 ( 0.00%) 0          0                      0              0          0             64,064 ( 0.09%)   3,182 ( 0.45%)   3,151 ( 0.98%)             0                  0          0          0           	 _counts[i] = 0;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void increase(unsigned int id) { // If each sub-counter belongs to a thread mutual exclusion is not needed
    2,018,144 ( 0.03%) 0          0              1,009,072 ( 0.08%)     0          0                  0                0                0              1,009,072 ( 0.06%)         0          0          0                 assert(id < _numcount);
    4,036,304 ( 0.07%) 0          0              1,009,072 ( 0.08%) 4,049 ( 0.61%) 0          1,009,072 ( 1.35%)       0                0                      0                  0          0          0                 _counts[id]++;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void xincrease(unsigned int id) { // Safe increment
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 assert(id < _numcount);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 const std::lock_guard<std::mutex> lock(cmutex);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 _counts[id]++;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned int get(unsigned int id) const { // return subcounter value for specific thread
        8,008 ( 0.00%) 0          0                      0              0          0                  0                0                0                  4,004 ( 0.00%)         0          0          0                 assert(id < _numcount);
        8,008 ( 0.00%) 0          0                  4,004 ( 0.00%) 1,000 ( 0.15%) 0                  0                0                0                      0                  0          0          0                 return _counts[id];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void inspect() {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 std::cout << "Subcounts -- ";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 for(int i=0; i<_numcount; i++)
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           	 std::cout << i << ":" << _counts[i] << " ";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 std::cout << "\n";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
-- line 51 ----------------------------------------
-- line 54 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned volatile int *_counts;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned int _numcount; // Per-thread subcounts 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              std::mutex cmutex;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           struct Range { // Integer range
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Range(int a=1, int b=0) { // Constructor. Defaults to *bad* range
      501,501 ( 0.01%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0            501,501 ( 0.67%)  61,876 ( 8.81%)  61,876 (19.20%)             0                  0          0          0                 lo = a;
    1,003,000 ( 0.02%) 0          0                      0              0          0            501,500 ( 0.67%)       0                0                      0                  0          0          0                 hi = b;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              bool within(int val) const { // Return if val is within this range
2,515,675,477 (43.50%) 0          0          1,005,866,562 (80.26%) 1,099 ( 0.16%) 0                  0                0                0          1,005,866,562 (61.58%) 1,006,604 (32.78%) 0          0                  return(lo <= val && val <= hi);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              bool strictlyin(int val) const { // Return if val is strictly inside this range
    4,003,998 ( 0.07%) 0          0              2,001,999 ( 0.16%)     0          0                  0                0                0              2,001,999 ( 0.12%)        12 ( 0.00%) 0          0                  return(lo < val && val < hi);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int lo;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int hi; 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           class Ranges {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           public:
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Ranges() { // Initialize with a single unreal interval
            1 ( 0.00%) 0          0                      0              0          0                  0                0                0                      0                  0          0          0                 _num = 1;
            3 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       0                0                      0                  0          0          0                 _ranges = new Range(1, 0); // Started with this. Its not a real interval as nothing lies inside it.
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Ranges& operator+=(const Range range){ // Add one more interval to this list
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 if(newrange(range)) { // If it already exists, do not add
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    Range *oranges = _ranges;
    1,015,000 ( 0.02%) 0          0                      0              0          0              2,000 ( 0.00%)       0                0                501,500 ( 0.03%)     1,012 ( 0.03%) 0          0                    _ranges = new Range[_num+1];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    assert(NULL != _ranges);
    1,001,000 ( 0.02%) 0          0                      0              0          0                  0                0                0                500,500 ( 0.03%)     1,013 ( 0.03%) 0          0                    for(int r=0; r<_num; r++) { 
    1,001,000 ( 0.02%) 0          0              1,001,000 ( 0.08%)     0          0                  0                0                0                      0                  0          0          0                       set(r, oranges[r].lo, oranges[r].hi); // copy old intervals
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    set(_num++, range.lo, range.hi); // Add the new interval at the end
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 return *this;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int range(int val, bool strict = false) const { // Tell the range in which val lies (strict => boundary match not ok)
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  if(strict) {
    4,500,500 ( 0.08%) 2 ( 0.08%) 2 ( 0.09%)             0              0          0                  0                0                0              1,001,000 ( 0.06%)     2,002 ( 0.07%) 0          0                     for(int r=0; r<_num; r++) // Look through all intervals
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                        if(_ranges[r].strictlyin(val))
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                           return r;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  } else {
2,010,724,052 (34.77%) 0          0              1,009,072 ( 0.08%)     0          0                  0                0                0            502,933,281 (30.79%)         0          0          0                     for(int r=0; r<_num; r++) // Look through all intervals
  505,960,497 ( 8.75%) 0          0              1,009,072 ( 0.08%)     0          0                  0                0                0                      0                  0          0          0                        if(_ranges[r].within(val))
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                           return r;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  return BADRANGE; // Did not find any range
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void inspect() {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 for(int r=0; r<_num; r++) { 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    std::cout << r << "," << &_ranges[r] << ": " << _ranges[r].lo << ", " << _ranges[r].hi << "\n"; 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
        3,002 ( 0.00%) 0          0                      0              0          0                  0                0                0                      0                  0          0          0              int num() const { return _num; }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           private:
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Range *_ranges;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int   _num;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void set(int i, int lo, int hi) { // set the extreme values of a specific interval
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 if(i < _num) {
      502,500 ( 0.01%) 0          0                      0              0          0            501,500 ( 0.67%)       0                0                      0                  0          0          0                     _ranges[i].lo = lo;
    1,502,500 ( 0.03%) 0          0                      0              0          0            501,500 ( 0.67%)       0                0                      0                  0          0          0                     _ranges[i].hi = hi;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 }
        1,000 ( 0.00%) 0          0                  1,000 ( 0.00%)     0          0                  0                0                0                      0                  0          0          0              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              bool newrange(const Range r) { // Is the range r already in my list, or is it a new one?
        1,000 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0                  0                0                0                      0                  0          0          0                 return (range(r.lo, true) == BADRANGE && range(r.hi, true) == BADRANGE); // Overlaps are not allowed.
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           struct Data {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
    3,027,216 ( 0.05%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0          2,018,144 ( 2.71%) 252,268 (35.93%) 252,268 (78.29%)             0                  0          0          0              struct Item {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 int key;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 int value = -1;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned int ndata = 0;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Item *data = NULL;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            1 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       1 ( 0.00%)       0                      0                  0          0          0              Data(int n) { // n = Maximum number of items  storable
            1 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       0                0                      0                  0          0          0                 ndata = n;
    5,045,385 ( 0.09%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0                  3 ( 0.00%)       2 ( 0.00%)       0              2,018,147 ( 0.12%)        17 ( 0.00%) 0          0                 data = new Item[n];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 assert(NULL != data);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void reset() {
    2,018,146 ( 0.03%) 0          0                      0              0          0                  0                0                0              1,009,073 ( 0.06%)        21 ( 0.00%) 0          0                 for(int i=0; i<ndata; i++)
    2,018,149 ( 0.03%) 1 ( 0.04%) 1 ( 0.04%)             1 ( 0.00%)     0          0          1,009,072 ( 1.35%) 126,135 (17.96%)       0                      0                  0          0          0                    data[i].value = -1;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void inspect() {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 for(int i=0; i<ndata; i++)
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    std::cout << i << ": " << data[i].key << " -- " << data[i].value <<"\n";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/final/main.cpp
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr                 D1mr       DLmr       Dw                 D1mw       DLmw       Bc                 Bcm        Bi         Bim        

        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           #include <unistd.h>
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           #include <iostream>
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           #include <fstream>
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           #include <chrono>
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           #include "classify.h"
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           float timedwork(Data &D, const Ranges &R, unsigned int numt)
        8 ( 0.00%) 2 ( 0.08%) 1 ( 0.04%)         0          0          0                  4 ( 0.00%) 0          0                  0          0          0          0           {
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .              // starttimer();
        2 ( 0.00%) 0          0                  0          0          0                  1 ( 0.00%) 0          0                  0          0          0          0              auto begin = std::chrono::high_resolution_clock::now();
        4 ( 0.00%) 0          0                  0          0          0                  1 ( 0.00%) 0          0                  0          0          0          0              Data D2 = classify(D, R, numt);
        1 ( 0.00%) 0          0                  0          0          0                  1 ( 0.00%) 0          0                  0          0          0          0              auto end = std::chrono::high_resolution_clock::now();
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .              auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .              // return(1e-6 * elapsed.count());
        4 ( 0.00%) 0          0                  1 ( 0.00%) 1 ( 0.00%) 0                  0          0          0                  0          0          0          0              return(1e-6 * (std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin)).count());
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .              // return mssince();
        6 ( 0.00%) 0          0                  5 ( 0.00%) 1 ( 0.00%) 0                  0          0          0                  0          0          0          0           }
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           void repeatrun(unsigned int reps, Data &D, const Ranges &R, unsigned int numt)
       10 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0                  5 ( 0.00%) 0          0                  0          0          0          0           { // Repeat the same experiment. Time each rep. D, R, and numt remain fixed.
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .              int it;
        5 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1 ( 0.00%) 1 ( 0.00%) 1 ( 0.01%)         2 ( 0.00%) 0          0                  0          0          0          0              float ms, tms = 0, minms = 1e7;
        6 ( 0.00%) 0          0                  0          0          0                  0          0          0                  2 ( 0.00%) 0          0          0              for(it=0; it<reps; it++) {
        8 ( 0.00%) 0          0                  1 ( 0.00%) 0          0                  2 ( 0.00%) 0          0                  0          0          0          0                 tms += ms = timedwork(D, R, numt); // This is the real work
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .                 std::cout << ms << " ms\n";
        2 ( 0.00%) 0          0                  0          0          0                  1 ( 0.00%) 0          0                  0          0          0          0                 usleep(1000); // Lose control for 1 ms 
        3 ( 0.00%) 0          0                  2 ( 0.00%) 0          0                  1 ( 0.00%) 0          0                  0          0          0          0                 if(ms < minms) minms = ms;
        1 ( 0.00%) 0          0                  1 ( 0.00%) 1 ( 0.00%) 0                  0          0          0                  0          0          0          0                 D.reset();
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .              }
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .              std::cout << reps << " iterations of " << D.ndata << " items in " 
        4 ( 0.00%) 0          0                  1 ( 0.00%) 0          0                  1 ( 0.00%) 0          0                  0          0          0          0                        << R.num() << " ranges with " << numt << " threads: Fastest took "
        4 ( 0.00%) 0          0                  1 ( 0.00%) 0          0                  0          0          0                  0          0          0          0                        << minms << " ms, Average was " << tms/reps << " ms\n";
        6 ( 0.00%) 0          0                  5 ( 0.00%) 0          0                  0          0          0                  0          0          0          0           }
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           Ranges readRanges(const char *filename)
        8 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0                  6 ( 0.00%) 0          0                  0          0          0          0           {
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               Ranges R;
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               std::fstream fs(filename, std::fstream::in);
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               int lo, hi;
  510,509 ( 0.01%) 1 ( 0.04%) 1 ( 0.04%)     2,002 ( 0.00%) 0          0              2,002 ( 0.00%) 0          0              1,001 ( 0.00%) 1 ( 0.00%) 0          0               while (fs >> lo >> hi)
    5,000 ( 0.00%) 0          0              2,000 ( 0.00%) 0          0                  0          0          0                  0          0          0          0                   R += Range(lo, hi);
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               fs.close();
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           
        1 ( 0.00%) 0          0                  0          0          0                  0          0          0                  0          0          0          0               return R;
       10 ( 0.00%) 0          0                  7 ( 0.00%) 1 ( 0.00%) 0                  0          0          0                  0          0          0          0           }
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           Data readData(const char *filename, unsigned int nItems)
        8 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0                  6 ( 0.00%) 0          0                  0          0          0          0           {
        2 ( 0.00%) 0          0                  0          0          0                  0          0          0                  1 ( 0.00%) 0          0          0               assert(nItems > 0);
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               Data D(nItems);
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               std::fstream fs(filename, std::fstream::in);
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               int d = 0;
8,072,576 ( 0.14%) 0          0          2,018,144 ( 0.16%) 0          0          1,009,072 ( 1.35%) 0          0                  0          0          0          0               while (fs >> D.data[d++].key)
3,027,216 ( 0.05%) 0          0                  0          0          0                  0          0          0          1,009,072 ( 0.06%) 1 ( 0.00%) 0          0                  if(d == nItems)
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .                     break;
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               if(d < nItems)
        2 ( 0.00%) 0          0                  0          0          0                  0          0          0                  0          0          0          0                  D.ndata = d-1;
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               fs.close();
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .               return D;
       10 ( 0.00%) 0          0                  7 ( 0.00%) 1 ( 0.00%) 0                  0          0          0                  0          0          0          0           }
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           int main(int argc, char *argv[])
        4 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         0          0          0                  3 ( 0.00%) 0          0                  0          0          0          0           {
        3 ( 0.00%) 0          0                  0          0          0                  0          0          0                  1 ( 0.00%) 0          0          0              assert(argc > 4); // <rangefile> <datafile> <max data to read> <number of threads to use>
        6 ( 0.00%) 0          0                  1 ( 0.00%) 1 ( 0.00%) 0                  3 ( 0.00%) 0          0                  0          0          0          0              Ranges R = readRanges(argv[1]);
        4 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1 ( 0.00%) 0          0                  3 ( 0.00%) 0          0                  0          0          0          0              Data D = readData(argv[2], atoi(argv[3]));
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .              int reps = 6; // 6 reps by default
        2 ( 0.00%) 0          0                  0          0          0                  0          0          0                  1 ( 0.00%) 1 ( 0.00%) 0          0              if(argc == 6) // If there is a reps arg, use it
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .                 reps = atoi(argv[5]);
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .           
        4 ( 0.00%) 0          0                  0          0          0                  1 ( 0.00%) 0          0                  0          0          0          0              repeatrun(reps, D, R, atoi(argv[4])); // repeat reps times
        .          .          .                  .          .          .                  .          .          .                  .          .          .          .              return 0;
        8 ( 0.00%) 3 ( 0.11%) 1 ( 0.04%)         4 ( 0.00%) 1 ( 0.00%) 0                  0          0          0                  0          0          0          0           }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/basic_string.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/char_traits.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf

--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                     D1mr             DLmr       Dw                 D1mw             DLmw             Bc                     Bcm                Bi         Bim        
--------------------------------------------------------------------------------
5,101,707,154 (88.22%) 35 ( 1.32%) 32 ( 1.39%) 1,025,033,858 (81.79%) 642,018 (96.00%) 1 ( 0.01%) 9,141,681 (12.25%) 569,728 (81.14%) 317,360 (98.49%) 1,519,947,447 (93.05%) 1,011,735 (32.95%) 0          0           events annotated

