--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./classify rfile dfile 1009072 4 1
Data file:        cachegrind.out.26682
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      I1mr           ILmr           Dr                     D1mr                 DLmr            Dw                  D1mw             DLmw             
--------------------------------------------------------------------------------
11,839,349,091 (100.0%) 2,706 (100.0%) 2,329 (100.0%) 2,258,272,605 (100.0%) 126,934,344 (100.0%) 10,720 (100.0%) 74,601,258 (100.0%) 702,921 (100.0%) 322,132 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                     D1mr                 DLmr           Dw                  D1mw             DLmw              file:function
--------------------------------------------------------------------------------
6,067,562,036 (51.25%)   3 ( 0.11%)   3 ( 0.13%) 1,014,119,402 (44.91%) 126,266,168 (99.47%)     0           1,009,096 ( 1.35%) 127,017 (18.07%)       0           /home/cse/dual/cs5190421/COL380/a1/classify_v1.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]
5,039,423,538 (42.57%)   1 ( 0.04%)   1 ( 0.04%) 1,009,902,850 (44.72%)       4,664 ( 0.00%)     0           1,009,072 ( 1.35%)       0                0           /home/cse/dual/cs5190421/COL380/a1/classify.h:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]
  234,188,449 ( 1.98%)  18 ( 0.67%)  14 ( 0.60%)    55,455,676 ( 2.46%)           8 ( 0.00%)     0          27,066,072 (36.28%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
  124,914,753 ( 1.06%)   6 ( 0.22%)   5 ( 0.21%)    40,289,597 ( 1.78%)           0              0           6,844,633 ( 9.17%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   97,070,475 ( 0.82%)   7 ( 0.26%)   6 ( 0.26%)    52,969,461 ( 2.35%)         336 ( 0.00%)   120 ( 1.12%)  6,845,468 ( 9.18%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   56,001,000 ( 0.47%)   1 ( 0.04%)   1 ( 0.04%)    15,711,408 ( 0.70%)           0              0           1,011,072 ( 1.36%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   39,432,111 ( 0.33%)   5 ( 0.18%)   5 ( 0.21%)    15,166,099 ( 0.67%)           5 ( 0.00%)     1 ( 0.01%)  6,066,442 ( 8.13%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::sentry::sentry(std::istream&, bool)
   34,376,486 ( 0.29%)   3 ( 0.11%)   3 ( 0.13%)    10,110,730 ( 0.45%)           0              0           6,066,440 ( 8.13%) 126,135 (17.94%)       0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::operator>>(int&)
   21,232,533 ( 0.18%)   3 ( 0.11%)   1 ( 0.04%)     9,099,657 ( 0.40%)           8 ( 0.00%)     0           5,055,365 ( 6.78%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::__use_cache<std::__numpunct_cache<char> >::operator()(std::locale const&) const
   16,145,270 ( 0.14%)  12 ( 0.44%)  12 ( 0.52%)     3,027,243 ( 0.13%)          10 ( 0.00%)     0           2,018,191 ( 2.71%) 126,136 (17.94%) 126,134 (39.16%)  ???:readData(char const*, unsigned int)
   15,549,617 ( 0.13%)  15 ( 0.55%)  15 ( 0.64%)     3,009,031 ( 0.13%)          10 ( 0.00%)     0           2,010,050 ( 2.69%)  61,876 ( 8.80%)  61,876 (19.21%)  ???:readRanges(char const*)
   12,132,864 ( 0.10%)   1 ( 0.04%)   1 ( 0.04%)     4,044,288 ( 0.18%)           2 ( 0.00%)     0           3,033,216 ( 4.07%)       0                0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istream::operator>>(int&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/classify_v1.cpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr                 DLmr       Dw                 D1mw             DLmw        

            .          .          .                      .                    .          .                  .                .           .           #include "classify.h"
            .          .          .                      .                    .          .                  .                .           .           #include <omp.h>
            .          .          .                      .                    .          .                  .                .           .           
            .          .          .                      .                    .          .                  .                .           .           Data classify(Data &D, const Ranges &R, unsigned int numt)
           10 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0                    0          0                  8 ( 0.00%)       0           0           { // Classify each item in D into intervals (given by R). Finally, produce in D2 data sorted by interval
            2 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0                    0          0                  0                0           0              assert(numt < MAXTHREADS);
            3 ( 0.00%) 0          0                      2 ( 0.00%)           0          0                  0                0           0              int RLen=R.num();
            3 ( 0.00%) 0          0                      2 ( 0.00%)           0          0                  1 ( 0.00%)       0           0              int nData=D.ndata;
        2,015 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0                    0          0                  1 ( 0.00%)       0           0              Counter counts[RLen]; // I need on counter per interval. Each counter can keep pre-thread subcount.
           73 ( 0.00%) 2 ( 0.07%) 2 ( 0.09%)            39 ( 0.00%)          12 ( 0.00%) 0                 26 ( 0.00%)       4 ( 0.00%)  2 ( 0.00%)  #pragma omp parallel num_threads(numt)
            .          .          .                      .                    .          .                  .                .           .              {
            4 ( 0.00%) 0          0                      0                    0          0                  4 ( 0.00%)       0           0                 int tid = omp_get_thread_num(); // I am thread number tid
    2,018,152 ( 0.02%) 0          0                      0                    0          0                  0                0           0                 for (int i = tid; i <nData; i += numt)
            .          .          .                      .                    .          .                  .                .           .                 {                                                    // Threads together share-loop through all of Data
    4,036,304 ( 0.03%) 1 ( 0.04%) 1 ( 0.04%)     1,009,084 ( 0.04%)     504,473 ( 0.40%) 0          1,009,072 ( 1.35%)      16 ( 0.00%)  0                    int v = D.data[i].value = R.range(D.data[i].key); // For each data, find the interval of data's key,
            .          .          .                      .                    .          .                  .                .           .                                                                      // and store the interval id in value. D is changed.
    1,009,076 ( 0.01%) 0          0              1,009,072 ( 0.04%)       4,016 ( 0.00%) 0                  0                0           0                    counts[v].increase(tid); // Found one key in interval v
            .          .          .                      .                    .          .                  .                .           .                 }
            .          .          .                      .                    .          .                  .                .           .              }
            .          .          .                      .                    .          .                  .                .           .           
            .          .          .                      .                    .          .                  .                .           .              // Accumulate all sub-counts (in each interval;'s counter) into rangecount
            7 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             2 ( 0.00%)           1 ( 0.00%) 0                  1 ( 0.00%)       0           0              unsigned int *rangecount = new unsigned int[RLen];
            .          .          .                      .                    .          .                  .                .           .           //    memset(rangecount,0,sizeof(rangecount));
        2,010 ( 0.00%) 0          0                      0                    0          0                  0                0           0              for (int r = 0; r < RLen; r++)
            .          .          .                      .                    .          .                  .                .           .              { // For all intervals
        1,001 ( 0.00%) 0          0                      0                    0          0              1,001 ( 0.00%)      63 ( 0.01%) 62 ( 0.02%)        rangecount[r] = 0;
       17,017 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         2,002 ( 0.00%)       1,001 ( 0.00%) 0                  0                0           0                 for (int t = 0; t < numt; t++) // For all threads
        4,004 ( 0.00%) 0          0                  4,004 ( 0.00%)           0          0                  0                0           0                    rangecount[r] += counts[r].get(t);
            .          .          .                      .                    .          .                  .                .           .                 // std::cout << rangecount[r] << " elements in Range " << r << "\n"; // Debugging statement
            .          .          .                      .                    .          .                  .                .           .              }
            .          .          .                      .                    .          .                  .                .           .           
            .          .          .                      .                    .          .                  .                .           .              // Compute prefx sum on rangecount.
        2,006 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0                    0          0                  0                0           0              for (int i = 1; i < RLen; i++)
            .          .          .                      .                    .          .                  .                .           .              {
        3,000 ( 0.00%) 0          0                  2,000 ( 0.00%)          48 ( 0.00%) 0                  0                0           0                 rangecount[i] += rangecount[i - 1];
            .          .          .                      .                    .          .                  .                .           .              }
            .          .          .                      .                    .          .                  .                .           .           
            .          .          .                      .                    .          .                  .                .           .              // Now rangecount[i] has the number of elements in intervals before the ith interval.
            .          .          .                      .                    .          .                  .                .           .           
            .          .          .                      .                    .          .                  .                .           .              Data D2 = Data(nData); // Make a copy
            .          .          .                      .                    .          .                  .                .           .           
           78 ( 0.00%) 2 ( 0.07%) 2 ( 0.09%)            42 ( 0.00%)          11 ( 0.00%) 0                 27 ( 0.00%)       5 ( 0.00%)  0           #pragma omp parallel num_threads(numt)
            .          .          .                      .                    .          .                  .                .           .              {
            4 ( 0.00%) 0          0                      0                    0          0                  4 ( 0.00%)       0           0                 int tid = omp_get_thread_num();
        2,022 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0                    0          0                  0                0           0                 for (int r = tid; r < RLen; r += numt)
            .          .          .                      .                    .          .                  .                .           .                 { // Thread together share-loop through the intervals
            .          .          .                      .                    .          .                  .                .           .                   //  int rcount = 0;
        1,001 ( 0.00%) 0          0                      0                    0          0                  0                0           0                    int rcount = -1;
2,020,165,147 (17.06%) 0          0                      0                    0          0                  0                0           0                    for (int d = 0; d < nData; d++)                        // For each interval, thread loops through all of data and
2,020,162,144 (17.06%) 1 ( 0.04%) 1 ( 0.04%) 1,010,081,072 (44.73%) 126,261,164 (99.47%) 0                  0                0           0                       if (D.data[d].value == r)                             // If the data item is in this interval
            .          .          .                      .                    .          .                  .                .           .                          {
    1,009,072 ( 0.01%) 0          0                      0                    0          0                  0                0           0                              rcount++;
2,026,222,582 (17.11%) 0          0              4,038,290 ( 0.18%)       4,994 ( 0.00%) 0          1,009,072 ( 1.35%) 127,014 (18.07%)  0                          D2.data[rangecount[r - 1] + rcount] = D.data[d]; // Copy it to the appropriate place in D2.
            .          .          .                      .                    .          .                  .                .           .                       //    D2.data[rangecount[r - 1] + rcount++] = D.data[d]; // Copy it to the appropriate place in D2.
            .          .          .                      .                    .          .                  .                .           .            }
            .          .          .                      .                    .          .                  .                .           .                 }
            .          .          .                      .                    .          .                  .                .           .              }
            .          .          .                      .                    .          .                  .                .           .           
            2 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             2 ( 0.00%)           0          0                  0                0           0              return D2;
           10 ( 0.00%) 0          0                      7 ( 0.00%)           1 ( 0.00%) 0                  0                0           0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/classify.h
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr           DLmr       Dw                 D1mw             DLmw             

-- line 13 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .           Data classify(Data &D, const Ranges &R, unsigned int numt);
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .           class alignas(32) Counter
            .          .          .                      .              .          .                  .                .                .           {  // Aligned allocation per counter. Is that enough?
            .          .          .                      .              .          .                  .                .                .              // Keeps per-thread subcount.
            .          .          .                      .              .          .                  .                .                .           public:
            .          .          .                      .              .          .                  .                .                .              Counter(unsigned int num = MAXTHREADS)
            .          .          .                      .              .          .                  .                .                .              {
        1,001 ( 0.00%) 0          0                      0              0          0              1,001 ( 0.00%)       0                0                 _numcount = num;
        3,003 ( 0.00%) 0          0                      0              0          0              2,002 ( 0.00%)       1 ( 0.00%)       1 ( 0.00%)        _counts = new unsigned int[num];
            .          .          .                      .              .          .                  .                .                .                 assert(_counts != NULL);
            .          .          .                      .              .          .                  .                .                .                 zero();
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              void zero()
            .          .          .                      .              .          .                  .                .                .              { // Initialize
      135,135 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1,001 ( 0.00%)     0          0                  0                0                0                 for (int i = 0; i < _numcount; i++)
      128,128 ( 0.00%) 0          0                      0              0          0             64,064 ( 0.09%)   3,174 ( 0.45%)   3,151 ( 0.98%)           _counts[i] = 0;
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              void increase(unsigned int id)
            .          .          .                      .              .          .                  .                .                .              { // If each sub-counter belongs to a thread mutual exclusion is not needed
    2,018,144 ( 0.02%) 0          0              1,009,072 ( 0.04%)     0          0                  0                0                0                 assert(id < _numcount);
    5,045,368 ( 0.04%) 0          0              1,009,072 ( 0.04%) 4,016 ( 0.00%) 0          1,009,072 ( 1.35%)       0                0                 _counts[id]++;
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              void xincrease(unsigned int id)
            .          .          .                      .              .          .                  .                .                .              { // Safe increment
            .          .          .                      .              .          .                  .                .                .                 assert(id < _numcount);
            .          .          .                      .              .          .                  .                .                .                 const std::lock_guard<std::mutex> lock(cmutex);
            .          .          .                      .              .          .                  .                .                .                 _counts[id]++;
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              unsigned int get(unsigned int id) const
            .          .          .                      .              .          .                  .                .                .              { // return subcounter value for specific thread
        8,008 ( 0.00%) 0          0                      0              0          0                  0                0                0                 assert(id < _numcount);
        8,008 ( 0.00%) 0          0                  4,004 ( 0.00%) 1,000 ( 0.00%) 0                  0                0                0                 return _counts[id];
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              void inspect()
            .          .          .                      .              .          .                  .                .                .              {
            .          .          .                      .              .          .                  .                .                .                 std::cout << "Subcounts -- ";
            .          .          .                      .              .          .                  .                .                .                 for (int i = 0; i < _numcount; i++)
            .          .          .                      .              .          .                  .                .                .                    std::cout << i << ":" << _counts[i] << " ";
            .          .          .                      .              .          .                  .                .                .                 std::cout << "\n";
-- line 57 ----------------------------------------
-- line 69 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .              Range(int a = 1, int b = 0)
            .          .          .                      .              .          .                  .                .                .              { // Constructor. Defaults to *bad* range
            .          .          .                      .              .          .                  .                .                .                 lo = a;
            .          .          .                      .              .          .                  .                .                .                 hi = b;
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              bool within(int val) const
            .          .          .                      .              .          .                  .                .                .              { // Return if val is within this range
2,515,675,477 (21.25%) 0          0          1,005,866,562 (44.54%)   648 ( 0.00%) 0                  0                0                0                 return (lo <= val && val <= hi);
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              bool strictlyin(int val) const
            .          .          .                      .              .          .                  .                .                .              { // Return if val is strictly inside this range
            .          .          .                      .              .          .                  .                .                .                 return (lo < val && val < hi);
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              int lo;
-- line 85 ----------------------------------------
-- line 116 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .                 if (strict)
            .          .          .                      .              .          .                  .                .                .                 {
            .          .          .                      .              .          .                  .                .                .                    for (int r = 0; r < _num; r++) // Look through all intervals
            .          .          .                      .              .          .                  .                .                .                       if (_ranges[r].strictlyin(val))
            .          .          .                      .              .          .                  .                .                .                          return r;
            .          .          .                      .              .          .                  .                .                .                 }
            .          .          .                      .              .          .                  .                .                .                 else
            .          .          .                      .              .          .                  .                .                .                 {
2,010,724,052 (16.98%) 0          0              1,009,072 ( 0.04%)     0          0                  0                0                0                    for (int r = 0; r < _num; r++) // Look through all intervals
  505,960,497 ( 4.27%) 1 ( 0.04%) 1 ( 0.04%)     1,009,072 ( 0.04%)     0          0                  0                0                0                       if (_ranges[r].within(val))
            .          .          .                      .              .          .                  .                .                .                          return r;
            .          .          .                      .              .          .                  .                .                .                 }
            .          .          .                      .              .          .                  .                .                .                 return BADRANGE; // Did not find any range
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              void inspect()
            .          .          .                      .              .          .                  .                .                .              {
            .          .          .                      .              .          .                  .                .                .                 for (int r = 0; r < _num; r++)
-- line 133 ----------------------------------------
-- line 155 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .              {                                                                           // Is the range r already in my list, or is it a new one?
            .          .          .                      .              .          .                  .                .                .                 return (range(r.lo, true) == BADRANGE && range(r.hi, true) == BADRANGE); // Overlaps are not allowed.
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           };
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .           struct Data
            .          .          .                      .              .          .                  .                .                .           {
            .          .          .                      .              .          .                  .                .                .           
    1,009,072 ( 0.01%) 0          0                      0              0          0          1,009,072 ( 1.35%) 126,134 (17.94%) 126,134 (39.16%)     struct Item
            .          .          .                      .              .          .                  .                .                .              {
            .          .          .                      .              .          .                  .                .                .                 int key;
            .          .          .                      .              .          .                  .                .                .                 int value = -1;
            .          .          .                      .              .          .                  .                .                .              };
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              unsigned int ndata = 0;
            .          .          .                      .              .          .                  .                .                .              Item *data = NULL;
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              Data(int n)
            1 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       0                0              { // n = Maximum number of items  storable
            2 ( 0.00%) 0          0                      1 ( 0.00%)     1 ( 0.00%) 0                  1 ( 0.00%)       0                0                 ndata = n;
    3,027,230 ( 0.03%) 1 ( 0.04%) 1 ( 0.04%)             1 ( 0.00%)     0          0                  3 ( 0.00%)       1 ( 0.00%)       0                 data = new Item[n];
            .          .          .                      .              .          .                  .                .                .                 assert(NULL != data);
            .          .          .                      .              .          .                  .                .                .              }
            .          .          .                      .              .          .                  .                .                .           
            .          .          .                      .              .          .                  .                .                .              void reset()
            .          .          .                      .              .          .                  .                .                .              {
            .          .          .                      .              .          .                  .                .                .                 for (int i = 0; i < ndata; i++)
            .          .          .                      .              .          .                  .                .                .                    data[i].value = -1;
            .          .          .                      .              .          .                  .                .                .              }
-- line 183 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf

--------------------------------------------------------------------------------
Ir                      I1mr        ILmr        Dr                     D1mr                 DLmr       Dw                 D1mw             DLmw             
--------------------------------------------------------------------------------
11,118,399,875 (93.91%) 17 ( 0.63%) 17 ( 0.73%) 2,026,053,477 (89.72%) 126,781,386 (99.88%) 0          4,104,433 ( 5.50%) 256,412 (36.48%) 129,350 (40.15%)  events annotated

