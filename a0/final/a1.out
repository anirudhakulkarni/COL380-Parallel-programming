--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./classify rfile dfile 1009072 4 1
Data file:        cachegrind.out.18602
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Thresholds:       0.1 100 100 100 100 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      I1mr           ILmr           Dr                     D1mr                 DLmr            Dw                  D1mw             DLmw             Bc                     Bcm                Bi                 Bim          
--------------------------------------------------------------------------------
11,832,372,270 (100.0%) 2,653 (100.0%) 2,305 (100.0%) 2,257,271,411 (100.0%) 126,807,717 (100.0%) 10,708 (100.0%) 74,597,093 (100.0%) 702,919 (100.0%) 322,132 (100.0%) 3,651,724,209 (100.0%) 3,073,948 (100.0%) 5,073,129 (100.0%) 848 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                     D1mr                 DLmr           Dw                  D1mw             DLmw             Bc                     Bcm                Bi                 Bim           file:function
--------------------------------------------------------------------------------
6,067,561,055 (51.28%)   3 ( 0.11%)   3 ( 0.13%) 1,014,119,414 (44.93%) 126,265,233 (99.57%)     0           1,009,100 ( 1.35%) 127,017 (18.07%)       0          2,020,164,150 (55.32%)     3,126 ( 0.10%)         0            0           /home/cse/dual/cs5190421/COL380/a1/final/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]
5,038,414,474 (42.58%)   1 ( 0.04%)   1 ( 0.04%) 1,009,902,850 (44.74%)       5,099 ( 0.00%)     0           1,009,072 ( 1.35%)       0                0          1,509,808,915 (41.35%) 1,006,609 (32.75%)         0            0           /home/cse/dual/cs5190421/COL380/a1/final/classify.h:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]
  234,188,449 ( 1.98%)  19 ( 0.72%)  14 ( 0.61%)    55,455,676 ( 2.46%)           8 ( 0.00%)     0          27,066,072 (36.28%)       0                0             37,722,129 ( 1.03%) 1,011,102 (32.89%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
  124,914,753 ( 1.06%)   6 ( 0.23%)   5 ( 0.22%)    40,289,597 ( 1.78%)           0              0           6,844,633 ( 9.18%)       0                0             16,723,317 ( 0.46%)        10 ( 0.00%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   97,070,475 ( 0.82%)   7 ( 0.26%)   6 ( 0.26%)    52,969,461 ( 2.35%)         336 ( 0.00%)   120 ( 1.12%)  6,845,468 ( 9.18%)       0                0             22,556,043 ( 0.62%)       838 ( 0.03%)       835 ( 0.02%)   1 ( 0.12%)  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   56,001,000 ( 0.47%)   1 ( 0.04%)   1 ( 0.04%)    15,711,408 ( 0.70%)           0              0           1,011,072 ( 1.36%)       0                0             15,711,408 ( 0.43%) 1,011,073 (32.89%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   39,432,111 ( 0.33%)   5 ( 0.19%)   5 ( 0.22%)    15,166,099 ( 0.67%)           5 ( 0.00%)     1 ( 0.01%)  6,066,442 ( 8.13%)       0                0              7,077,634 ( 0.19%)        40 ( 0.00%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::sentry::sentry(std::istream&, bool)
   34,376,486 ( 0.29%)   4 ( 0.15%)   3 ( 0.13%)    10,110,730 ( 0.45%)           0              0           6,066,440 ( 8.13%) 126,135 (17.94%)       0              4,044,290 ( 0.11%)         8 ( 0.00%)         0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc:std::istream::operator>>(int&)
   21,232,512 ( 0.18%)   2 ( 0.08%)   1 ( 0.04%)     9,099,648 ( 0.40%)           4 ( 0.00%)     0           5,055,360 ( 6.78%)       0                0              1,011,072 ( 0.03%)         0                  0            0           /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc:std::__use_cache<std::__numpunct_cache<char> >::operator()(std::locale const&) const
   15,033,003 ( 0.13%)   4 ( 0.15%)   4 ( 0.17%)     3,003,999 ( 0.13%)           0              0           2,008,002 ( 2.69%)  61,876 ( 8.80%)  61,876 (19.21%)     4,004,999 ( 0.11%)     4,039 ( 0.13%)         0            0           /home/cse/dual/cs5190421/COL380/a1/final/classify.h:readRanges(char const*)
   12,132,864 ( 0.10%)   1 ( 0.04%)   1 ( 0.04%)     4,044,288 ( 0.18%)           1 ( 0.00%)     0           3,033,216 ( 4.07%)       0                0                      0                  0          1,011,072 (19.93%)   1 ( 0.12%)  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h:std::istream::operator>>(int&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/final/classify.cpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr                 DLmr       Dw                 D1mw             DLmw        Bc                     Bcm            Bi         Bim        

            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           #include "classify.h"
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           #include <omp.h>
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           // #include <atomic>
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           Data classify(Data &D, const Ranges &R, unsigned int numt)
            9 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0                    0          0                  7 ( 0.00%)       0           0                      0              0          0          0           { // Classify each item in D into intervals (given by R). Finally, produce in D2 data sorted by interval
            2 ( 0.00%) 0          0                      0                    0          0                  0                0           0                      1 ( 0.00%)     0          0          0              assert(numt < MAXTHREADS);
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              // std::atomic<int> rcountArray [1001];
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              // for (int r = 0; r < R.num(); r++)
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              //  { // For all intervals
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              //      rcountArray[r] = 0;
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              //  }
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           
        2,016 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             1 ( 0.00%)           0          0                  0                0           0                  1,002 ( 0.00%)     3 ( 0.00%) 0          0              Counter counts[R.num()]; // I need on counter per interval. Each counter can keep pre-thread subcount.
           66 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)            33 ( 0.00%)          13 ( 0.00%) 0                 25 ( 0.00%)       4 ( 0.00%)  2 ( 0.00%)             0              0          0          0              #pragma omp parallel num_threads(numt)
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              {
            4 ( 0.00%) 0          0                      0                    0          0                  4 ( 0.00%)       0           0                      0              0          0          0                 int tid = omp_get_thread_num(); // I am thread number tid
    4,036,300 ( 0.03%) 0          0              1,009,080 ( 0.04%)           1 ( 0.00%) 0                  0                0           0              1,009,076 ( 0.03%)     4 ( 0.00%) 0          0                 for(int i=tid; i<D.ndata; i+=numt) { // Threads together share-loop through all of Data
    4,036,300 ( 0.03%) 1 ( 0.04%) 1 ( 0.04%)     1,009,080 ( 0.04%)     504,538 ( 0.40%) 0          1,009,072 ( 1.35%)      40 ( 0.01%)  0                      0              0          0          0                    int v = D.data[i].value = R.range(D.data[i].key);// For each data, find the interval of data's key,
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           							  // and store the interval id in value. D is changed.
    1,009,072 ( 0.01%) 0          0              1,009,072 ( 0.04%)       4,040 ( 0.00%) 0                  0                0           0                      0              0          0          0                    counts[v].increase(tid); // Found one key in interval v
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .                 }
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              }
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              // Accumulate all sub-counts (in each interval;'s counter) into rangecount
            7 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             1 ( 0.00%)           0          0                  1 ( 0.00%)       0           0                      1 ( 0.00%)     0          0          0              unsigned int *rangecount = new unsigned int[R.num()];
        2,011 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             1 ( 0.00%)           0          0                  0                0           0                  1,002 ( 0.00%)     3 ( 0.00%) 0          0              for(int r=0; r<R.num(); r++) { // For all intervals
        1,001 ( 0.00%) 0          0                      0                    0          0              1,001 ( 0.00%)      63 ( 0.01%) 62 ( 0.02%)             0              0          0          0                 rangecount[r] = 0;
       15,015 ( 0.00%) 0          0                  2,002 ( 0.00%)       1,001 ( 0.00%) 0                  0                0           0                  5,005 ( 0.00%)    10 ( 0.00%) 0          0                 for(int t=0; t<numt; t++) // For all threads
        4,004 ( 0.00%) 0          0                  4,004 ( 0.00%)           0          0                  0                0           0                      0              0          0          0                    rangecount[r] += counts[r].get(t);
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .                 // std::cout << rangecount[r] << " elements in Range " << r << "\n"; // Debugging statement
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              }
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              // Compute prefx sum on rangecount.
        2,006 ( 0.00%) 0          0                      0                    0          0                  0                0           0                  1,001 ( 0.00%)     9 ( 0.00%) 0          0              for(int i=1; i<R.num(); i++) {
        2,000 ( 0.00%) 0          0                  2,000 ( 0.00%)          48 ( 0.00%) 0                  0                0           0                      0              0          0          0                 rangecount[i] += rangecount[i-1];
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              }
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              // Now rangecount[i] has the number of elements in intervals before the ith interval.
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           
            2 ( 0.00%) 0          0                      2 ( 0.00%)           2 ( 0.00%) 0                  0                0           0                      0              0          0          0              Data D2 = Data(D.ndata); // Make a copy
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              
           84 ( 0.00%) 2 ( 0.08%) 2 ( 0.09%)            37 ( 0.00%)          12 ( 0.00%) 0                 30 ( 0.00%)       5 ( 0.00%)  0                      0              0          0          0              #pragma omp parallel num_threads(numt)
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              {
            4 ( 0.00%) 0          0                      0                    0          0                  4 ( 0.00%)       0           0                      0              0          0          0                 int tid = omp_get_thread_num();
        2,034 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)         1,017 ( 0.00%)       1,005 ( 0.00%) 0                  0                0           0                  1,005 ( 0.00%)     5 ( 0.00%) 0          0                 for(int r=tid; r<R.num(); r+=numt) { // Thread together share-loop through the intervals 
        1,001 ( 0.00%) 0          0                      0                    0          0                  0                0           0                      0              0          0          0                    int rcount = 0;
2,020,166,148 (17.07%) 0          0                  1,001 ( 0.00%)           0          0                  0                0           0          1,010,082,073 (27.66%) 1,027 ( 0.03%) 0          0                    for(int d=0; d<D.ndata; d++) // For each interval, thread loops through all of data and  
2,020,162,144 (17.07%) 1 ( 0.04%) 1 ( 0.04%) 1,010,081,072 (44.75%) 126,261,220 (99.57%) 0                  0                0           0          1,010,081,072 (27.66%) 2,094 ( 0.07%) 0          0                        if(D.data[d].value == r) // If the data item is in this interval 
2,027,229,652 (17.13%) 0          0              4,036,288 ( 0.18%)       2,997 ( 0.00%) 0          1,009,072 ( 1.35%) 127,014 (18.07%)  0                      0              0          0          0                            D2.data[rangecount[r-1]+rcount++] = D.data[d]; // Copy it to the appropriate place in D2.
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .                 }
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .                 // int tid=omp_get_thread_num();
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .                 // int start=tid*D.ndata/numt, end= std::min(((tid + 1) * D.ndata) / numt,D.ndata);
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .                 // for(int d=start;d<end;d++){
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .                 //    int r=D.data[d].value;
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .                 //    D2.data[rangecount[r-1]+rcountArray[r]++]=D.data[d];
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .                 // }
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .              }
            .          .          .                      .                    .          .                  .                .           .                      .              .          .          .           
            2 ( 0.00%) 0          0                      2 ( 0.00%)           0          0                  0                0           0                      0              0          0          0              return D2;
           10 ( 0.00%) 0          0                      7 ( 0.00%)           1 ( 0.00%) 0                  0                0           0                      0              0          0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/cse/dual/cs5190421/COL380/a1/final/classify.h
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr           DLmr       Dw                 D1mw             DLmw             Bc                     Bcm                Bi         Bim        

-- line 11 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           class Ranges;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           Data classify(Data &D, const Ranges &R, unsigned int numt);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           class alignas(32) Counter { // Aligned allocation per counter. Is that enough?
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           			    // Keeps per-thread subcount.
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           public:
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Counter(unsigned int num=MAXTHREADS) {
        1,001 ( 0.00%) 0          0                      0              0          0              1,001 ( 0.00%)       0                0                      0                  0          0          0                 _numcount = num;
        3,003 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0              2,002 ( 0.00%)       1 ( 0.00%)       1 ( 0.00%)             0                  0          0          0                 _counts = new unsigned int[num];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 assert(_counts != NULL);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 zero();
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void zero() { // Initialize
      135,135 ( 0.00%) 0          0                  1,001 ( 0.00%)     0          0                  0                0                0                 65,065 ( 0.00%)     1,018 ( 0.03%) 0          0                 for(int i=0; i<_numcount; i++)
      128,128 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0             64,064 ( 0.09%)   3,175 ( 0.45%)   3,151 ( 0.98%)             0                  0          0          0           	 _counts[i] = 0;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void increase(unsigned int id) { // If each sub-counter belongs to a thread mutual exclusion is not needed
    2,018,144 ( 0.02%) 0          0              1,009,072 ( 0.04%)     0          0                  0                0                0              1,009,072 ( 0.03%)         3 ( 0.00%) 0          0                 assert(id < _numcount);
    4,036,304 ( 0.03%) 0          0              1,009,072 ( 0.04%) 4,041 ( 0.00%) 0          1,009,072 ( 1.35%)       0                0                      0                  0          0          0                 _counts[id]++;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void xincrease(unsigned int id) { // Safe increment
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 assert(id < _numcount);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 const std::lock_guard<std::mutex> lock(cmutex);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 _counts[id]++;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned int get(unsigned int id) const { // return subcounter value for specific thread
        8,008 ( 0.00%) 0          0                      0              0          0                  0                0                0                  4,004 ( 0.00%)         1 ( 0.00%) 0          0                 assert(id < _numcount);
        8,008 ( 0.00%) 0          0                  4,004 ( 0.00%) 1,000 ( 0.00%) 0                  0                0                0                      0                  0          0          0                 return _counts[id];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void inspect() {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 std::cout << "Subcounts -- ";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 for(int i=0; i<_numcount; i++)
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           	 std::cout << i << ":" << _counts[i] << " ";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 std::cout << "\n";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
-- line 51 ----------------------------------------
-- line 54 ----------------------------------------
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned volatile int *_counts;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned int _numcount; // Per-thread subcounts 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              std::mutex cmutex;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           struct Range { // Integer range
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Range(int a=1, int b=0) { // Constructor. Defaults to *bad* range
      501,501 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0            501,501 ( 0.67%)  61,876 ( 8.80%)  61,876 (19.21%)             0                  0          0          0                 lo = a;
    1,003,000 ( 0.01%) 0          0                      0              0          0            501,500 ( 0.67%)       0                0                      0                  0          0          0                 hi = b;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              bool within(int val) const { // Return if val is within this range
2,515,675,477 (21.26%) 0          0          1,005,866,562 (44.56%) 1,058 ( 0.00%) 0                  0                0                0          1,005,866,562 (27.54%) 1,006,605 (32.75%) 0          0                  return(lo <= val && val <= hi);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              bool strictlyin(int val) const { // Return if val is strictly inside this range
    4,003,998 ( 0.03%) 0          0              2,001,999 ( 0.09%)     0          0                  0                0                0              2,001,999 ( 0.05%)        12 ( 0.00%) 0          0                  return(lo < val && val < hi);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int lo;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int hi; 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           class Ranges {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           public:
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Ranges() { // Initialize with a single unreal interval
            1 ( 0.00%) 0          0                      0              0          0                  0                0                0                      0                  0          0          0                 _num = 1;
            3 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       0                0                      0                  0          0          0                 _ranges = new Range(1, 0); // Started with this. Its not a real interval as nothing lies inside it.
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Ranges& operator+=(const Range range){ // Add one more interval to this list
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 if(newrange(range)) { // If it already exists, do not add
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    Range *oranges = _ranges;
    1,015,000 ( 0.01%) 0          0                      0              0          0              2,000 ( 0.00%)       0                0                501,500 ( 0.01%)     1,012 ( 0.03%) 0          0                    _ranges = new Range[_num+1];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    assert(NULL != _ranges);
    1,001,000 ( 0.01%) 0          0                      0              0          0                  0                0                0                500,500 ( 0.01%)     1,013 ( 0.03%) 0          0                    for(int r=0; r<_num; r++) { 
    1,001,000 ( 0.01%) 0          0              1,001,000 ( 0.04%)     0          0                  0                0                0                      0                  0          0          0                       set(r, oranges[r].lo, oranges[r].hi); // copy old intervals
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    set(_num++, range.lo, range.hi); // Add the new interval at the end
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 return *this;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int range(int val, bool strict = false) const { // Tell the range in which val lies (strict => boundary match not ok)
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  if(strict) {
    4,500,500 ( 0.04%) 2 ( 0.08%) 2 ( 0.09%)             0              0          0                  0                0                0              1,001,000 ( 0.03%)     2,002 ( 0.07%) 0          0                     for(int r=0; r<_num; r++) // Look through all intervals
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                        if(_ranges[r].strictlyin(val))
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                           return r;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  } else {
2,010,724,052 (16.99%) 1 ( 0.04%) 1 ( 0.04%)     1,009,072 ( 0.04%)     0          0                  0                0                0            502,933,281 (13.77%)         1 ( 0.00%) 0          0                     for(int r=0; r<_num; r++) // Look through all intervals
  505,960,497 ( 4.28%) 0          0              1,009,072 ( 0.04%)     0          0                  0                0                0                      0                  0          0          0                        if(_ranges[r].within(val))
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                           return r;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                  return BADRANGE; // Did not find any range
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void inspect() {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 for(int r=0; r<_num; r++) { 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    std::cout << r << "," << &_ranges[r] << ": " << _ranges[r].lo << ", " << _ranges[r].hi << "\n"; 
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
        3,002 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0                  0                0                0                      0                  0          0          0              int num() const { return _num; }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           private:
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Range *_ranges;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              int   _num;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void set(int i, int lo, int hi) { // set the extreme values of a specific interval
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 if(i < _num) {
      502,500 ( 0.00%) 0          0                      0              0          0            501,500 ( 0.67%)       0                0                      0                  0          0          0                     _ranges[i].lo = lo;
    1,502,500 ( 0.01%) 0          0                      0              0          0            501,500 ( 0.67%)       0                0                      0                  0          0          0                     _ranges[i].hi = hi;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 }
        1,000 ( 0.00%) 0          0                  1,000 ( 0.00%)     0          0                  0                0                0                      0                  0          0          0              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              bool newrange(const Range r) { // Is the range r already in my list, or is it a new one?
        1,000 ( 0.00%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0                  0                0                0                      0                  0          0          0                 return (range(r.lo, true) == BADRANGE && range(r.hi, true) == BADRANGE); // Overlaps are not allowed.
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           struct Data {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
    3,027,216 ( 0.03%) 1 ( 0.04%) 1 ( 0.04%)             0              0          0          2,018,144 ( 2.71%) 252,268 (35.89%) 252,268 (78.31%)             0                  0          0          0              struct Item {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 int key;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 int value = -1;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              };
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              unsigned int ndata = 0;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              Item *data = NULL;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            1 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       0                0                      0                  0          0          0              Data(int n) { // n = Maximum number of items  storable
            1 ( 0.00%) 0          0                      0              0          0                  1 ( 0.00%)       0                0                      0                  0          0          0                 ndata = n;
    5,045,387 ( 0.04%) 2 ( 0.08%) 2 ( 0.09%)             1 ( 0.00%)     0          0                  4 ( 0.00%)       1 ( 0.00%)       0              2,018,147 ( 0.06%)        12 ( 0.00%) 0          0                 data = new Item[n];
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 assert(NULL != data);
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void reset() {
    2,018,146 ( 0.02%) 0          0                      0              0          0                  0                0                0              1,009,073 ( 0.03%)        21 ( 0.00%) 0          0                 for(int i=0; i<ndata; i++)
    2,018,149 ( 0.02%) 1 ( 0.04%) 1 ( 0.04%)             1 ( 0.00%)     0          0          1,009,072 ( 1.35%) 126,135 (17.94%)       0                      0                  0          0          0                    data[i].value = -1;
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              void inspect() {
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                 for(int i=0; i<ndata; i++)
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .                    std::cout << i << ": " << data[i].key << " -- " << data[i].value <<"\n";
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .              }
            .          .          .                      .              .          .                  .                .                .                      .                  .          .          .           };

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/istream.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/locale_facets.tcc
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/streambuf_iterator.h
  /home/cc/vfaculty/omj.vfaculty/IITD/centOS7/GCC/gcc-9.1.0/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf

--------------------------------------------------------------------------------
Ir                      I1mr        ILmr        Dr                     D1mr                 DLmr       Dw                 D1mw             DLmw             Bc                     Bcm                Bi         Bim        
--------------------------------------------------------------------------------
11,142,513,556 (94.17%) 22 ( 0.83%) 22 ( 0.95%) 2,030,066,556 (89.93%) 126,780,977 (99.98%) 0          8,130,579 (10.90%) 570,582 (81.17%) 317,360 (98.52%) 3,538,091,441 (96.89%) 1,014,855 (33.01%) 0          0           events annotated

